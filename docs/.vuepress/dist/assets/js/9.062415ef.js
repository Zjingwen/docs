(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{304:function(a,t,r){"use strict";r.r(t);var i=r(38),v=Object(i.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"react新的前端思维方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react新的前端思维方式","aria-hidden":"true"}},[a._v("#")]),a._v(" React新的前端思维方式")]),a._v(" "),r("p",[a._v("[TOC]")]),a._v(" "),r("h2",{attrs:{id:"什么是组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是组件")]),a._v(" "),r("ul",[r("li",[a._v("能完成某个特定功能的独立的、可复用的代码")])]),a._v(" "),r("h2",{attrs:{id:"为什么要引入react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要引入react","aria-hidden":"true"}},[a._v("#")]),a._v(" 为什么要引入react")]),a._v(" "),r("ul",[r("li",[a._v("代码中就算并没有直接使用react，也一定要导入react，因为jsx最终会被转译成依赖于react的表达式")])]),a._v(" "),r("h2",{attrs:{id:"jsx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jsx","aria-hidden":"true"}},[a._v("#")]),a._v(" JSX")]),a._v(" "),r("ul",[r("li",[a._v("javasript的语法扩展，让html能在javascript中编写")]),a._v(" "),r("li",[a._v("JSX中使用的“元素”不局限于html中的元素，可以是任何一个React组件")]),a._v(" "),r("li",[a._v("使React组件可以把javascript、html、css的功能集中在一个文件中")])]),a._v(" "),r("h2",{attrs:{id:"判断jsx中是html元素还是react组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断jsx中是html元素还是react组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 判断JSX中是HTML元素还是react组件")]),a._v(" "),r("ul",[r("li",[a._v("判断一个元素是html元素还是React组件的原则就是看到第一个字母是否大写")])]),a._v(" "),r("h2",{attrs:{id:"onclick和onclick"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#onclick和onclick","aria-hidden":"true"}},[a._v("#")]),a._v(" onclick和onClick")]),a._v(" "),r("p",[a._v("onclick")]),a._v(" "),r("ul",[r("li",[a._v("onclick添加的事件是在全局环境下执行，会污染全局环境")]),a._v(" "),r("li",[a._v("给很多dom元素添加onclick事件，可能会影响网页性能")]),a._v(" "),r("li",[a._v("如果要动态的从DOM树中删除DOM元素的话，需要把对应的事件处理器注销，假如忘记注销，就可能会造成内存泄漏")])]),a._v(" "),r("p",[a._v("onClick")]),a._v(" "),r("ul",[r("li",[a._v("onClick挂载的每个函数，都可以控制在组件范围内，不会污染全局")]),a._v(" "),r("li",[a._v("使用了事件委托，无论有多少个onClick出现，其实最后都只在DOM树上添加了一个事件处理函数，挂在最顶层的DOM节点上")]),a._v(" "),r("li",[a._v("所有的点击事件都被这个事件处理函数捕获，然后根据具体组件分配给特定函数，使用事件委托的性能当然要为每个onClick挂载一个事件处理函数要高")]),a._v(" "),r("li",[a._v("React控制了组件的生命周期，在unmount的时候自然能清楚相关的所有事件处理函数")])]),a._v(" "),r("h2",{attrs:{id:"react理念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react理念","aria-hidden":"true"}},[a._v("#")]),a._v(" React理念")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("UI=render(data)")]),a._v("用户看到的界面（UI），应该是一个函数（render）的执行结果，只接受数据（data）作为参数")]),a._v(" "),r("li",[a._v("响应式编程")]),a._v(" "),r("li",[a._v("基于组件来开发应用")])]),a._v(" "),r("h2",{attrs:{id:"virtual-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom","aria-hidden":"true"}},[a._v("#")]),a._v(" Virtual DOM")]),a._v(" "),r("ul",[r("li",[a._v("每次渲染都只重新渲染最少的DOM元素")]),a._v(" "),r("li",[a._v("DOM是结构化文本的抽象表达形式")]),a._v(" "),r("li",[a._v("Virtual DOM是对DOM树的抽象，不会触及浏览器的部分，只存在于javascript空间的树形结构，每次渲染，只会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对于发现差异，后然修改真正的DOM，只修改触及差异中的部分（只更新变化处，整个DOM不会全部重新渲染。）")])]),a._v(" "),r("h2",{attrs:{id:"dom树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dom树","aria-hidden":"true"}},[a._v("#")]),a._v(" DOM树")]),a._v(" "),r("ul",[r("li",[a._v("HTML中的每一个元素都对应DOM中的某一个节点，DOM节点浏览器为了渲染HTML格式的网页，优先将HTML文本解析以构建DOM树，然后根据DOM树渲染出用户看到的界面，改变界面内容时，就去改变DOM树上的节点")])]),a._v(" "),r("h2",{attrs:{id:"使用react的好处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用react的好处","aria-hidden":"true"}},[a._v("#")]),a._v(" 使用React的好处")]),a._v(" "),r("ul",[r("li",[a._v("避免构建负责的程序结构")]),a._v(" "),r("li",[a._v("利用函数式编程的思维来解决用户界面渲染的问题")]),a._v(" "),r("li",[a._v("提高开发者效率")]),a._v(" "),r("li",[a._v("代码可维护性和可阅读性增强")]),a._v(" "),r("li",[a._v("强制所有组件都按照数据驱动渲染，无论应用规模，都能保证程序处于可控范围")])])])},[],!1,null,null,null);t.default=v.exports}}]);