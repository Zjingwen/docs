<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React-demo | 伪公知的生活常态</title>
    <meta name="description" content="就是随便写写而已">
    
    
    <link rel="preload" href="/docs-interview/assets/css/0.styles.5db48745.css" as="style"><link rel="preload" href="/docs-interview/assets/js/app.95d31192.js" as="script"><link rel="preload" href="/docs-interview/assets/js/2.387e38e1.js" as="script"><link rel="preload" href="/docs-interview/assets/js/16.d53c70f1.js" as="script"><link rel="prefetch" href="/docs-interview/assets/js/10.3d791bab.js"><link rel="prefetch" href="/docs-interview/assets/js/100.26536cc9.js"><link rel="prefetch" href="/docs-interview/assets/js/101.ef604d61.js"><link rel="prefetch" href="/docs-interview/assets/js/102.7e3745f8.js"><link rel="prefetch" href="/docs-interview/assets/js/103.dd883182.js"><link rel="prefetch" href="/docs-interview/assets/js/104.79252216.js"><link rel="prefetch" href="/docs-interview/assets/js/105.c827c675.js"><link rel="prefetch" href="/docs-interview/assets/js/106.89a21ec7.js"><link rel="prefetch" href="/docs-interview/assets/js/107.0c04e9d8.js"><link rel="prefetch" href="/docs-interview/assets/js/108.d49a0e1d.js"><link rel="prefetch" href="/docs-interview/assets/js/109.8fa00ff0.js"><link rel="prefetch" href="/docs-interview/assets/js/11.e7b6e7fe.js"><link rel="prefetch" href="/docs-interview/assets/js/110.eb0cdcaa.js"><link rel="prefetch" href="/docs-interview/assets/js/111.5d84d049.js"><link rel="prefetch" href="/docs-interview/assets/js/112.026e50e0.js"><link rel="prefetch" href="/docs-interview/assets/js/113.4af81b4c.js"><link rel="prefetch" href="/docs-interview/assets/js/114.65b24c1f.js"><link rel="prefetch" href="/docs-interview/assets/js/115.ab03d442.js"><link rel="prefetch" href="/docs-interview/assets/js/116.4cabfb7a.js"><link rel="prefetch" href="/docs-interview/assets/js/117.b866a639.js"><link rel="prefetch" href="/docs-interview/assets/js/118.4e903d7a.js"><link rel="prefetch" href="/docs-interview/assets/js/119.6d8406b8.js"><link rel="prefetch" href="/docs-interview/assets/js/12.d872e8ea.js"><link rel="prefetch" href="/docs-interview/assets/js/120.10dbccf5.js"><link rel="prefetch" href="/docs-interview/assets/js/121.f62c4740.js"><link rel="prefetch" href="/docs-interview/assets/js/122.2e228b20.js"><link rel="prefetch" href="/docs-interview/assets/js/123.ee925db9.js"><link rel="prefetch" href="/docs-interview/assets/js/124.cbb6d23a.js"><link rel="prefetch" href="/docs-interview/assets/js/125.71f51813.js"><link rel="prefetch" href="/docs-interview/assets/js/126.8001dc97.js"><link rel="prefetch" href="/docs-interview/assets/js/127.0a8c3722.js"><link rel="prefetch" href="/docs-interview/assets/js/128.e12abd8a.js"><link rel="prefetch" href="/docs-interview/assets/js/129.522f352d.js"><link rel="prefetch" href="/docs-interview/assets/js/13.7b075aef.js"><link rel="prefetch" href="/docs-interview/assets/js/130.19f0c66a.js"><link rel="prefetch" href="/docs-interview/assets/js/131.f00f9466.js"><link rel="prefetch" href="/docs-interview/assets/js/132.4b0118bd.js"><link rel="prefetch" href="/docs-interview/assets/js/133.f3f8534a.js"><link rel="prefetch" href="/docs-interview/assets/js/134.65772645.js"><link rel="prefetch" href="/docs-interview/assets/js/135.c110e3ec.js"><link rel="prefetch" href="/docs-interview/assets/js/136.47679aee.js"><link rel="prefetch" href="/docs-interview/assets/js/137.3cb1e73e.js"><link rel="prefetch" href="/docs-interview/assets/js/138.83e86e9f.js"><link rel="prefetch" href="/docs-interview/assets/js/139.ac6b71e3.js"><link rel="prefetch" href="/docs-interview/assets/js/14.a4e38186.js"><link rel="prefetch" href="/docs-interview/assets/js/140.79b340d4.js"><link rel="prefetch" href="/docs-interview/assets/js/141.4b3c867a.js"><link rel="prefetch" href="/docs-interview/assets/js/142.be834fd0.js"><link rel="prefetch" href="/docs-interview/assets/js/143.b147bf79.js"><link rel="prefetch" href="/docs-interview/assets/js/144.0573c750.js"><link rel="prefetch" href="/docs-interview/assets/js/15.13b1d63f.js"><link rel="prefetch" href="/docs-interview/assets/js/17.17b5fcbe.js"><link rel="prefetch" href="/docs-interview/assets/js/18.5589dd51.js"><link rel="prefetch" href="/docs-interview/assets/js/19.446dab5a.js"><link rel="prefetch" href="/docs-interview/assets/js/20.351088ff.js"><link rel="prefetch" href="/docs-interview/assets/js/21.dceec1d2.js"><link rel="prefetch" href="/docs-interview/assets/js/22.fa7f6c47.js"><link rel="prefetch" href="/docs-interview/assets/js/23.a2c2a19a.js"><link rel="prefetch" href="/docs-interview/assets/js/24.b5676ea3.js"><link rel="prefetch" href="/docs-interview/assets/js/25.eb9588a1.js"><link rel="prefetch" href="/docs-interview/assets/js/26.cf397d24.js"><link rel="prefetch" href="/docs-interview/assets/js/27.1da5c841.js"><link rel="prefetch" href="/docs-interview/assets/js/28.26285cb6.js"><link rel="prefetch" href="/docs-interview/assets/js/29.4d4a7d7f.js"><link rel="prefetch" href="/docs-interview/assets/js/3.e24aff58.js"><link rel="prefetch" href="/docs-interview/assets/js/30.21cc19bf.js"><link rel="prefetch" href="/docs-interview/assets/js/31.f1b289e2.js"><link rel="prefetch" href="/docs-interview/assets/js/32.723e67e2.js"><link rel="prefetch" href="/docs-interview/assets/js/33.02053b5b.js"><link rel="prefetch" href="/docs-interview/assets/js/34.5e62f8a4.js"><link rel="prefetch" href="/docs-interview/assets/js/35.63c58f1e.js"><link rel="prefetch" href="/docs-interview/assets/js/36.06f274ed.js"><link rel="prefetch" href="/docs-interview/assets/js/37.ea004859.js"><link rel="prefetch" href="/docs-interview/assets/js/38.d3d9c594.js"><link rel="prefetch" href="/docs-interview/assets/js/39.c5af91c3.js"><link rel="prefetch" href="/docs-interview/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/docs-interview/assets/js/40.d48fe4bb.js"><link rel="prefetch" href="/docs-interview/assets/js/41.b2215e85.js"><link rel="prefetch" href="/docs-interview/assets/js/42.6ecc20b2.js"><link rel="prefetch" href="/docs-interview/assets/js/43.d48d7214.js"><link rel="prefetch" href="/docs-interview/assets/js/44.f56d3e66.js"><link rel="prefetch" href="/docs-interview/assets/js/45.7c5d2214.js"><link rel="prefetch" href="/docs-interview/assets/js/46.cad73163.js"><link rel="prefetch" href="/docs-interview/assets/js/47.3a25ff94.js"><link rel="prefetch" href="/docs-interview/assets/js/48.98d159e1.js"><link rel="prefetch" href="/docs-interview/assets/js/49.fe28623a.js"><link rel="prefetch" href="/docs-interview/assets/js/5.cd3fd4c9.js"><link rel="prefetch" href="/docs-interview/assets/js/50.f2d2864e.js"><link rel="prefetch" href="/docs-interview/assets/js/51.3e9ede3a.js"><link rel="prefetch" href="/docs-interview/assets/js/52.ca7b5f42.js"><link rel="prefetch" href="/docs-interview/assets/js/53.b47bf86d.js"><link rel="prefetch" href="/docs-interview/assets/js/54.6a2cbaf5.js"><link rel="prefetch" href="/docs-interview/assets/js/55.91582a90.js"><link rel="prefetch" href="/docs-interview/assets/js/56.f86be0ea.js"><link rel="prefetch" href="/docs-interview/assets/js/57.9736ae8a.js"><link rel="prefetch" href="/docs-interview/assets/js/58.6733876e.js"><link rel="prefetch" href="/docs-interview/assets/js/59.4427ecfe.js"><link rel="prefetch" href="/docs-interview/assets/js/6.0d618875.js"><link rel="prefetch" href="/docs-interview/assets/js/60.b550f66b.js"><link rel="prefetch" href="/docs-interview/assets/js/61.ee9258ec.js"><link rel="prefetch" href="/docs-interview/assets/js/62.db3c66c4.js"><link rel="prefetch" href="/docs-interview/assets/js/63.d2fd7240.js"><link rel="prefetch" href="/docs-interview/assets/js/64.258b5a42.js"><link rel="prefetch" href="/docs-interview/assets/js/65.bb395bbf.js"><link rel="prefetch" href="/docs-interview/assets/js/66.bd6896bd.js"><link rel="prefetch" href="/docs-interview/assets/js/67.37657eee.js"><link rel="prefetch" href="/docs-interview/assets/js/68.d823ca9e.js"><link rel="prefetch" href="/docs-interview/assets/js/69.0f13b4d0.js"><link rel="prefetch" href="/docs-interview/assets/js/7.2302c4c8.js"><link rel="prefetch" href="/docs-interview/assets/js/70.2c1ecb69.js"><link rel="prefetch" href="/docs-interview/assets/js/71.6aee0b5d.js"><link rel="prefetch" href="/docs-interview/assets/js/72.9804d57b.js"><link rel="prefetch" href="/docs-interview/assets/js/73.a362afdf.js"><link rel="prefetch" href="/docs-interview/assets/js/74.00b3e003.js"><link rel="prefetch" href="/docs-interview/assets/js/75.3ba2741c.js"><link rel="prefetch" href="/docs-interview/assets/js/76.b155e834.js"><link rel="prefetch" href="/docs-interview/assets/js/77.c0806518.js"><link rel="prefetch" href="/docs-interview/assets/js/78.f145e4e5.js"><link rel="prefetch" href="/docs-interview/assets/js/79.b18eb052.js"><link rel="prefetch" href="/docs-interview/assets/js/8.01ef5034.js"><link rel="prefetch" href="/docs-interview/assets/js/80.166faa3b.js"><link rel="prefetch" href="/docs-interview/assets/js/81.a8e13dd1.js"><link rel="prefetch" href="/docs-interview/assets/js/82.bc659265.js"><link rel="prefetch" href="/docs-interview/assets/js/83.d4d2767e.js"><link rel="prefetch" href="/docs-interview/assets/js/84.e59df14e.js"><link rel="prefetch" href="/docs-interview/assets/js/85.60f7cc9e.js"><link rel="prefetch" href="/docs-interview/assets/js/86.02c79022.js"><link rel="prefetch" href="/docs-interview/assets/js/87.cd092a77.js"><link rel="prefetch" href="/docs-interview/assets/js/88.ce7120fa.js"><link rel="prefetch" href="/docs-interview/assets/js/89.eca17faa.js"><link rel="prefetch" href="/docs-interview/assets/js/9.062415ef.js"><link rel="prefetch" href="/docs-interview/assets/js/90.81085990.js"><link rel="prefetch" href="/docs-interview/assets/js/91.1dc2aee4.js"><link rel="prefetch" href="/docs-interview/assets/js/92.229f99c0.js"><link rel="prefetch" href="/docs-interview/assets/js/93.b4169369.js"><link rel="prefetch" href="/docs-interview/assets/js/94.fdf0a2cb.js"><link rel="prefetch" href="/docs-interview/assets/js/95.2fb1a9f0.js"><link rel="prefetch" href="/docs-interview/assets/js/96.2d63b1cb.js"><link rel="prefetch" href="/docs-interview/assets/js/97.efed770d.js"><link rel="prefetch" href="/docs-interview/assets/js/98.c6c86090.js"><link rel="prefetch" href="/docs-interview/assets/js/99.c0733e0b.js">
    <link rel="stylesheet" href="/docs-interview/assets/css/0.styles.5db48745.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs-interview/" class="home-link router-link-active"><!----> <span class="site-name">伪公知的生活常态</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs-interview/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/" class="sidebar-link">个人笔记</a></li><li><a href="/docs-interview/%E6%94%B6%E8%97%8F%E7%AC%94%E8%AE%B0/" class="sidebar-link">收藏笔记</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-demo"><a href="#react-demo" aria-hidden="true" class="header-anchor">#</a> React-demo</h1> <div class="language-text extra-class"><pre class="language-text"><code>react-demo: https://github.com/Zjingwen/react-demo
欢迎git clone
</code></pre></div><h2 id="react的方法"><a href="#react的方法" aria-hidden="true" class="header-anchor">#</a> React的方法</h2> <p><img src="https://lh3.googleusercontent.com/-jRhjzvFA3xI/W_uliAGt2wI/AAAAAAAAAF4/GbUq0TYYoagiQ2bhFq_GIQnako7FHnqkQCHMYCw/I/WechatIMG2006.png" alt="WechatIMG2006"></p> <h2 id="生命周期详解"><a href="#生命周期详解" aria-hidden="true" class="header-anchor">#</a> 生命周期详解</h2> <h3 id="constructor-实例化"><a href="#constructor-实例化" aria-hidden="true" class="header-anchor">#</a> constructor 实例化</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>实例化对象</li> <li>继承React.Component</li> <li>初始化state</li></ul> <h3 id="static-getderivedstatefromprops"><a href="#static-getderivedstatefromprops" aria-hidden="true" class="header-anchor">#</a> static getDerivedStateFromProps</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span>state</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>update更新时，render之前，dom渲染前</li> <li>必须有初始化state</li> <li>静态方法，没有this</li> <li>可以return出对象，设置state</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Count extends Component{
  constructor(props){
    super(props);
    this.state = {
      count: 0,
    }
  };

  static getDerivedStateFromProps(props){
    return {count: props.count*2};
  };

  render(){
    return (
      &lt;React.Fragment&gt;
        &lt;p&gt;Count-Child-state: {this.state.count}&lt;/p&gt;
        &lt;p&gt;Count-Child-props: {this.props.count}&lt;/p&gt;
      &lt;/React.Fragment&gt;
    )
  }
};

class Time extends Component{
  constructor(props){
    super(props);
    this.state={
      time: this.props.time,
    }
  };

  static getDerivedStateFromProps(props,state){
    console.log(state);
    return null;
  };

  handleClick(){
    this.setState({
      time: new Date().toString()
    });
  }

  render(){
    const {time} = this.state;
    return(
      &lt;React.Fragment&gt;
        &lt;input type='button' value='setState触发 详情看log' onClick={()=&gt;this.handleClick()}/&gt; 
        &lt;p&gt;{time}&lt;/p&gt;
      &lt;/React.Fragment&gt;
    )
  };
};

function GetDerivedStateFromPropsComponent (){
  const [count,setCount] = useState(0);
  const [time] = useState(new Date().toString());

  return (
    &lt;Fieldset title='getDerivedStateFromProps'&gt;
      &lt;input type='button' value='new props ++' onClick={()=&gt;setCount(s=&gt;s+1)}/&gt;
      &lt;Count count={count}/&gt;
      &lt;Time time={time}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h3 id="shouldcomponentupdate"><a href="#shouldcomponentupdate" aria-hidden="true" class="header-anchor">#</a> shouldComponentUpdate</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> Boolean
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>update更新时，render之前，dom渲染前</li> <li>return 一个布尔值来判断是否渲染</li> <li>默认return true</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Time extends Component{
  shouldComponentUpdate(nextPorps){
    if(this.props.time !== nextPorps.time){
      // 保证每次time不同时更新
      console.group('shouldComponent-props');
      console.log(nextPorps);
      console.log(this.props);
      console.groupEnd();
      return true;
    }
    return false;
  };
  
  render(){
    return(
      &lt;React.Fragment&gt;
        {this.props.time}
      &lt;/React.Fragment&gt;
    )
  }
};

function ShuldComponentUpdateComponent() {
  const [time,setTime] = useState(new Date().toString());

  return(
    &lt;Fieldset title='shuldComponentUpdate'&gt;
      &lt;input type='button' value='new Props' onClick={()=&gt;setTime(new Date().toString())} /&gt;
      &lt;Time time={time}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h3 id="render"><a href="#render" aria-hidden="true" class="header-anchor">#</a> render</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token constant">JSX</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>将jsx渲染为真实DOM</li></ul> <h3 id="getshapshotbeforeupdate"><a href="#getshapshotbeforeupdate" aria-hidden="true" class="header-anchor">#</a> getShapshotBeforeUpdate</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">getShapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span>prevState</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> ‘getShapshotBeforeUpdate’
	<span class="token punctuation">}</span>
	<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span>prevState<span class="token punctuation">,</span>snapshot</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	   <span class="token comment">// TODO snapshot == ‘getShapshotBeforeUpdate’</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>update更新时，render之前，dom渲染前</li> <li>无默认返回值，可返回null</li> <li>return 一个值，用来作为componentDidUpdate的第三个参数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Child extends Component {
  constructor(props) {
    super(props);
    this.state = {
      ...props,
    };
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    console.group('getSnapshotBeforeUpdate');
    console.log(prevProps);
    console.log(prevState);
    console.groupEnd();
    if (prevProps.time !== prevState.time) {
      this.setState({
        time: prevProps.time,
      });
    }
    return 'getSnapshotBeforeUpdate';
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.group('componentDidUpdate');
    console.log(prevProps);
    console.log(prevState);
    console.log(snapshot);
    console.groupEnd();
  }

  render() {
    return (
      &lt;p&gt;
        {this.state.time}
      &lt;/p&gt;
    );
  }
}

function GetShapshotBeforeUpdateComponent() {
  const [time, setTime] = useState(new Date().toString());

  return (
    &lt;Fieldset title='getShapshotBeforeUpdate'&gt;
      &lt;Child time={time} /&gt;
      &lt;input type='button' value='更新时间' onClick={()=&gt;setTime(new Date().toString())} /&gt;
    &lt;/Fieldset&gt;
  );
}
</code></pre></div><h3 id="componentdidmount"><a href="#componentdidmount" aria-hidden="true" class="header-anchor">#</a> componentDidMount</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>render之后，dom渲染后</li> <li>唯一的会在服务端渲染调起的生命周期钩子函数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Time extends Component {
  componentDidMount() {
    console.log('ComponentDidMount');
  }

  render() {
    return (
      &lt;p&gt;{new Date().toString()}&lt;/p&gt;
    );
  }
}

function ComponentDidMountComponent() {
  const [show, setShow] = useState(false);
  return (
    &lt;Fieldset title='componentDidMount'&gt;
      &lt;input type='button' value='触发componentDidMount' onClick={()=&gt;setShow(!show)} /&gt;
      { show &amp;&amp; &lt;Time /&gt;}
    &lt;/Fieldset&gt;
  );
}
</code></pre></div><h3 id="componentdidupdate"><a href="#componentdidupdate" aria-hidden="true" class="header-anchor">#</a> componentDidUpdate</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span>prevState<span class="token punctuation">,</span>snapshot</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>update更新时，render之后，dom渲染后</li> <li>snapshot为getShapshotBeforeUpdate的return</li></ul> <div class="language- extra-class"><pre class="language-text"><code>参照getShapshotBeforeUpdate的code demo
</code></pre></div><h3 id="componentwillunmount"><a href="#componentwillunmount" aria-hidden="true" class="header-anchor">#</a> componentWillUnmount</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
	<span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>dom卸载</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Time extends Component {
  componentWillUnmount() {
    console.log('componentWillUnmount');
  }
  render() {
    return (
      &lt;p&gt;{new Date().toString()}&lt;/p&gt;
    );
  };
}

function ComponentWillUnmountComponent() {
  const [show, setShow] = useState(true);
  return (
    &lt;Fieldset title='componentWillUnmount'&gt;
      &lt;input type='button' value='触发componentWillUnmount' onClick={()=&gt; setShow(!show)} /&gt;
      {show &amp;&amp; &lt;Time /&gt;}
    &lt;/Fieldset&gt;
  );
}
</code></pre></div><h3 id="componentdidcatch"><a href="#componentdidcatch" aria-hidden="true" class="header-anchor">#</a> componentDidCatch</h3> <div class="language- extra-class"><pre class="language-text"><code>class A extends React.Component{
    componentDidCatch(error,errorInfo){}
}
</code></pre></div><ul><li>只有在render中报错才会被捕获</li> <li>为什么不用try/catch：try/catch更加适合命令式代码，而componentDidCatch会捕获组件树中的报错</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state={
      error: false,
      errorInfo: null,
    };
  }

  componentDidCatch(error, errorInfo) {
    console.log(errorInfo.componentStack);
    this.setState({
      error: error.toString(),
      errorInfo: errorInfo.componentStack,
    });
  }

  render() {
    if (this.state.error) {
      return (
        &lt;div&gt;
          &lt;h1&gt;error: {this.state.error}&lt;/h1&gt;
          &lt;p&gt;
            errorInfo:{this.state.errorInfo}
          &lt;/p&gt;
        &lt;/div&gt;
      );
    }
    return this.props.children;
  }
};
ErrorBoundary.propTypes = {
  children: PropTypes.node.isRequired,
};

class Input extends Component {
  constructor() {
    super();
    this.state= {
      throw: false,
    };
  }

  handleClick() {
    this.setState((s)=&gt;({
      throw: !s.throws,
    }));
  }

  render() {
    if (this.state.throw) throw new Error('I throw');
    return &lt;input type='button' value='触发catch' onClick={()=&gt; this.handleClick()} /&gt;;
  }
};

function ComponentDidCatchComponent() {
  return (
    &lt;Fieldset title='componentDidCatch'&gt;
      &lt;ErrorBoundary&gt;
        &lt;Input /&gt;
      &lt;/ErrorBoundary&gt;
    &lt;/Fieldset&gt;
  );
};
</code></pre></div><h2 id="触发流程"><a href="#触发流程" aria-hidden="true" class="header-anchor">#</a> 触发流程</h2> <h3 id="初始化"><a href="#初始化" aria-hidden="true" class="header-anchor">#</a> 初始化</h3> <div class="language- extra-class"><pre class="language-text"><code>constructor()
static getDerivedStateFromProps(props,state)
render()
componentDidMount()
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Flow extends React.Component{
  constructor(){
    super();
    this.state = {};
    console.group('初始化阶段');
    console.log('constructor');
  };

  static getDerivedStateFromProps(){
    console.log('getDerivedStateFromProps');
    return null;
  };

  componentDidMount(){
    console.log('componentDidMount');
    console.groupEnd();
  }
  
  render(){
    console.log('render');
    return (
      &lt;p&gt;
        constructor&lt;br/&gt;
        |&lt;br/&gt;
        static getDerivedStateFromProps()&lt;br/&gt;
        |&lt;br/&gt;
        render&lt;br/&gt;
        |&lt;br/&gt;
        componentDidMount&lt;br/&gt;
      &lt;/p&gt;
    )
  };
}


function MountingComponent (){
  const [show,setShow] = useState(false);

  return (
    &lt;Fieldset title='初始化阶段'&gt;
      &lt;input type='button' value='查看初始化阶段，详情看log' onClick={()=&gt;setShow(!show)}/&gt;
      {show &amp;&amp; &lt;Flow/&gt;}
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h3 id="属性更新"><a href="#属性更新" aria-hidden="true" class="header-anchor">#</a> 属性更新</h3> <p>New Props</p> <div class="language- extra-class"><pre class="language-text"><code>static getDerivedStateFromProps(props,state)
shouldComponentUpdate(nextProps, nextState)
render()
getSnapshotBeforeUpdate(prevProps,prevState)
componentDidUpdate()
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Flow extends React.Component{
  state = {};

  static getDerivedStateFromProps(){
    console.group('触发传递新的props');
    console.log('getDevivedStateFromProps');
    return null;
  };

  shouldComponentUpdate(){
    console.log('shouldComponentUpdate');
    return true;
  };

  getSnapshotBeforeUpdate(){
    console.log('getSnapshotBeforeUpdate');
    return null;
  };

  componentDidUpdate(){
    console.log('componentDidUpdate');
    console.groupEnd();
  };

  render(){
    console.log('render');
    return(
      &lt;React.Fragment&gt;
        &lt;p&gt;{this.props.title}&lt;/p&gt;
        &lt;p&gt;
          static getDevivedStateFromPorps &lt;br/&gt;
          | &lt;br/&gt;
          shouldComponentUpdate &lt;br/&gt;
          | &lt;br/&gt;
          getSnapshotBeforeUpdate &lt;br/&gt;
          | &lt;br/&gt;
          componentDidUpdate
        &lt;/p&gt;
      &lt;/React.Fragment&gt;
    )
  }
};

function NewpropsComponent(){
  const [time,setTime] = useState(new Date().toString());

  return (
    &lt;Fieldset title='传递新的props'&gt;
      &lt;input type='button' value='触发传递新的props' onClick={()=&gt;setTime(new Date().toString())}/&gt;
      &lt;Flow title={time}/&gt;
    &lt;/Fieldset&gt;
  )
};

export default NewpropsComponent;
</code></pre></div><p>setState()</p> <div class="language- extra-class"><pre class="language-text"><code>static getDerivedStateFromProps()
shouldComponentUpdate()
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class SetStateComponent extends React.Component{
  state = {
    time: new Date().toString(),
  };
  
  static getDerivedStateFromProps(){
    console.group('设置属性');
    console.log('getDerivedStateFromProps');
    return null;
  };

  shouldComponentUpdate(){
    console.log('shouldComponentUpdate')
    return true;
  };

  getSnapshotBeforeUpdate(){
    console.log('getSnapshotBeforeUpdate');
    return null;
  };

  componentDidUpdate(){
    console.log('componentDidUpdate');
    console.groupEnd();
  };

  handleClick(){
    this.setState({
      time: new Date().toString()
    });
  }

  render(){
    console.log('render');
    return (
      &lt;Fieldset title='设置属性'&gt;
        &lt;input type='button' value='更新时间' onClick={()=&gt;this.handleClick()} /&gt;
        &lt;p&gt;{this.state.time}&lt;/p&gt;
        static getDerivedStateFromProps &lt;br /&gt;
        | &lt;br /&gt;
        shouldComponentUpdate &lt;br /&gt;
        | &lt;br /&gt;
        render &lt;br /&gt;
        | &lt;br /&gt;
        getSnapshotBeforeUpdate &lt;br /&gt;
        | &lt;br /&gt;
        componentDidUpdate &lt;br /&gt;
      &lt;/Fieldset&gt;
    )
  }
}
</code></pre></div><p>forceUpdate()</p> <div class="language- extra-class"><pre class="language-text"><code>getDerivedStateFromProps()
render()
getShapshotBeforeUpdate()
componentDidUpdate()
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class ForceUpdateComponent extends React.Component{
  state = {};

  static getDerivedStateFromProps(){
    console.group('forecUpdate更新');
    console.log('getDerivedStateFromProps');
    return true;
  };

  getSnapshotBeforeUpdate(){
    console.log('getShapshotBeforeUpdate');
    return null;
  };

  componentDidUpdate(){
    console.log('componentDidUpdate');
    console.groupEnd();
  }

  render(){
    console.log('render')
    return(
      &lt;Fieldset title='forecUpdate更新'&gt;
        &lt;input type='button' value='触发forecUpdae' onClick={()=&gt;this.forceUpdate()} /&gt; &lt;br/&gt;
        static getDerivedStateFromProps &lt;br/&gt;
        | &lt;br/&gt;
        getShapshotBeforeUpdate &lt;br/&gt;
        | &lt;br/&gt;
        componentDidUpdate &lt;br/&gt;
      &lt;/Fieldset&gt;
    )
  }
}
</code></pre></div><h2 id="触发生命周期的api"><a href="#触发生命周期的api" aria-hidden="true" class="header-anchor">#</a> 触发生命周期的api</h2> <h3 id="setstate-设置状态"><a href="#setstate-设置状态" aria-hidden="true" class="header-anchor">#</a> setState 设置状态</h3> <div class="language- extra-class"><pre class="language-text"><code>setState((State)=&gt;({object}),function callback])
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 完全写法
this.setState(State=&gt;({
    ...State
}),()=&gt;{
    ...
})

// 简单写法
this.setState({
    ...
})
</code></pre></div><ul><li>触发一轮生命周期<code>getDerivedStateFromProps-&gt;shouldComponentUpdate-&gt;render-&gt;getSnapshotBeforeUpdate-&gt;componentDidUpdate</code></li> <li>prevState为当前组件的state值</li> <li>callback，为状态设置之后，state经过所有生命周期后调用</li></ul> <h3 id="forceupage-强制更新"><a href="#forceupage-强制更新" aria-hidden="true" class="header-anchor">#</a> forceUpage 强制更新</h3> <div class="language- extra-class"><pre class="language-text"><code>forceUpage(function callback)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>this.forceUpage(()=&gt;{
    ...
})
</code></pre></div><ul><li>触发一轮生命周期<code>getDerivedStateFromProps-&gt;render-&gt;componentDidUpdate</code></li> <li>callback，为生命周期之后调用</li></ul> <h2 id="react-component"><a href="#react-component" aria-hidden="true" class="header-anchor">#</a> React.Component</h2> <ul><li>react的抽象基础类</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class A extends React.Component{}
</code></pre></div><h2 id="react-purecomponent"><a href="#react-purecomponent" aria-hidden="true" class="header-anchor">#</a> React.PureComponent</h2> <ul><li>内置一个浅比较，比较props和state，决定是否render，用于提高性能</li> <li>只是进行浅对比，无法对比复合数据</li> <li>用于避免无状态组件的重复渲染</li></ul> <div class="language- extra-class"><pre class="language-text"><code> class A extends React.PureComponent{}
</code></pre></div><h2 id="react-memo"><a href="#react-memo" aria-hidden="true" class="header-anchor">#</a> React.memo(()=&gt;{},()=&gt;{});</h2> <ul><li>组件仅在它的 props 发生改变的时候进行重新渲染</li> <li>和React.PureComponent类似功能一直，但这是一个纯函数用法</li> <li>只是进行浅对比，无法对比复合数据</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const A = React.memo((props)=&gt;{
    return JSX
},(prevProps,nextProps)=&gt;{
    return null | false
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>const MemoComponent = React.memo((props)=&gt;{
  return (
    &lt;div&gt;{props.time}&lt;/div&gt;
  );
}, (prevProps, nextProps)=&gt;{
  if (prevProps.time !== nextProps.time) {
    return null;
  }
  return false;
});

function Memo() {
  const [time, setTime] = useState(new Date().toString());

  return (
    &lt;Fieldset title='memo'&gt;
      memo
      &lt;input type='button' value='更新时间' onClick={()=&gt;setTime(new Date().toString())} /&gt;
      &lt;MemoComponent time={time} /&gt;
    &lt;/Fieldset&gt;
  );
};
</code></pre></div><h2 id="react-createref"><a href="#react-createref" aria-hidden="true" class="header-anchor">#</a> React.createRef()</h2> <ul><li>创建节点引用</li> <li>通过ref属性附加到React元素</li> <li>可以通过curent访问到节点</li> <li>ref更新发生在componentDidMount、componentDidUpdate时</li> <li>无法在函数组件上使用，因为没有实例</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class CreateRefComponent extends Component {
  constructor() {
    super();
    this.state = {
      el: null,
    };
    this.ref = React.createRef();
  }

  componentDidMount() {
    this.setState({
      el: this.ref.current.innerHTML,
    });
  }

  render() {
    return (
      &lt;Fieldset title='createRef'&gt;
        &lt;div ref={this.ref}&gt;createRef&lt;/div&gt;
        &lt;p&gt;el: {this.state.el}&lt;/p&gt;
      &lt;/Fieldset&gt;
    );
  }
}
</code></pre></div><h2 id="react-isvalidelement-object"><a href="#react-isvalidelement-object" aria-hidden="true" class="header-anchor">#</a> React.isValidElement(object)</h2> <ul><li>验证对象是否为React元素。返回true或false。</li> <li>必须传递一个对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let D = React.createElement('div');
React.isValidElement(D);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function ChildFunction() {
  return (
    &lt;div&gt;Child-function&lt;/div&gt;
  );
};

class ChildComponent extends Component {
  render() {
    return (
      &lt;div&gt;Child-Component&lt;/div&gt;
    );
  }
};

function IsValidElementComponent() {
  const D = React.createElement('div');

  return (
    &lt;Fieldset title='isValidElement'&gt;
      &lt;p&gt;createElement: {React.isValidElement(D).toString()}&lt;/p&gt;
      &lt;p&gt;Function Component: {React.isValidElement(ChildFunction()).toString()}&lt;/p&gt;
      &lt;p&gt;class Component: {React.isValidElement(&lt;ChildComponent /&gt;).toString()}&lt;/p&gt;
    &lt;/Fieldset&gt;
  );
};
</code></pre></div><h2 id="react-children"><a href="#react-children" aria-hidden="true" class="header-anchor">#</a> React.Children</h2> <ul><li>遍历children，返回数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>array React.Children.map(children,function callback) 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Map extends Component {
  render() {
    const arr = React.Children.map(this.props.children, (v)=&gt; v);

    return (
      &lt;Fieldset title='map'&gt;
        {arr}
      &lt;/Fieldset&gt;
    );
  }
};
Map.propTypes = {
  children: PropTypes.node.isRequired,
};

function Index() {
  return (
    &lt;Map&gt;
      &lt;p&gt;A&lt;/p&gt;
      &lt;p&gt;B&lt;/p&gt;
      &lt;p&gt;C&lt;/p&gt;
      &lt;p&gt;D&lt;/p&gt;
      &lt;p&gt;E&lt;/p&gt;
      &lt;p&gt;F&lt;/p&gt;
    &lt;/Map&gt;
  );
};
</code></pre></div><ul><li>遍历children，无返回</li></ul> <div class="language- extra-class"><pre class="language-text"><code>void React.Children.forEach(children,function callback) 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class ForEact extends Component {
  render() {
    const arr = [];
    React.Children.forEach(this.props.children, (v) =&gt; arr.push(v));
    return (
      &lt;Fieldset title='ForEact'&gt;
        {arr}
      &lt;/Fieldset&gt;
    );
  }
};
ForEact.propTypes = {
  children: PropTypes.node.isRequired,
};

function Index() {
  return (
    &lt;ForEact&gt;
      &lt;p&gt;A&lt;/p&gt;
      &lt;p&gt;B&lt;/p&gt;
      &lt;p&gt;C&lt;/p&gt;
      &lt;p&gt;D&lt;/p&gt;
      &lt;p&gt;E&lt;/p&gt;
      &lt;p&gt;F&lt;/p&gt;
    &lt;/ForEact&gt;
  );
};
</code></pre></div><ul><li>返回children的长度</li></ul> <div class="language- extra-class"><pre class="language-text"><code>number React.Children.count(children) 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Count extends Component {
  render() {
    const count = React.Children.count(this.props.children, (v)=&gt; v);

    return (
      &lt;Fieldset title='count'&gt;
        {count}
      &lt;/Fieldset&gt;
    );
  }
};
Count.propTypes = {
  children: PropTypes.node.isRequired,
};

function Index() {
  return (
    &lt;Count&gt;
      &lt;p&gt;A&lt;/p&gt;
      &lt;p&gt;B&lt;/p&gt;
      &lt;p&gt;C&lt;/p&gt;
      &lt;p&gt;D&lt;/p&gt;
      &lt;p&gt;E&lt;/p&gt;
      &lt;p&gt;F&lt;/p&gt;
    &lt;/Count&gt;
  );
};
</code></pre></div><ul><li>判断children是否为1，不为1报错</li></ul> <div class="language- extra-class"><pre class="language-text"><code>void React.Children.only(children) 
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Only extends Component {
  render() {
    const {title} = this.props;

    let e = null;
    let o = null;

    try {
      o = React.Children.only(this.props.children);
    } catch (error) {
      e = error;
    };
    return (
      &lt;Fieldset title={title}&gt;
        {e &amp;&amp; Object.keys(e).map((v) =&gt; e[v])}
        {o}
      &lt;/Fieldset&gt;
    );
  }
};
Only.propTypes = {
  children: PropTypes.node.isRequired,
  title: PropTypes.string.isRequired,
};

function Index() {
  return (
    &lt;React.Fragment&gt;
      &lt;Only title='not-Only'&gt;
        &lt;p&gt;A&lt;/p&gt;
        &lt;p&gt;B&lt;/p&gt;
        &lt;p&gt;C&lt;/p&gt;
        &lt;p&gt;D&lt;/p&gt;
        &lt;p&gt;E&lt;/p&gt;
        &lt;p&gt;F&lt;/p&gt;
      &lt;/Only&gt;
      &lt;Only title='Only'&gt;
        &lt;p&gt;A&lt;/p&gt;
      &lt;/Only&gt;
    &lt;/React.Fragment&gt;
  );
};
</code></pre></div><ul><li>把children，从对象转换为数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>array React.Children.toArray(children,function callback)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class ToArray extends Component {
  render() {
    const arr = React.Children.toArray(this.props.children);

    return (
      &lt;Fieldset title='toArray'&gt;
        &lt;p&gt;isArray: {Array.isArray(arr).toString()}&lt;/p&gt;
        {arr}
      &lt;/Fieldset&gt;
    );
  }
};
ToArray.propTypes = {
  children: PropTypes.node.isRequired,
};

function Index() {
  return (
    &lt;ToArray&gt;
      &lt;p&gt;A&lt;/p&gt;
      &lt;p&gt;B&lt;/p&gt;
      &lt;p&gt;C&lt;/p&gt;
      &lt;p&gt;D&lt;/p&gt;
      &lt;p&gt;E&lt;/p&gt;
      &lt;p&gt;F&lt;/p&gt;
    &lt;/ToArray&gt;
  );
};
</code></pre></div><h2 id="react-fragment"><a href="#react-fragment" aria-hidden="true" class="header-anchor">#</a> React.Fragment</h2> <ul><li>允许创建一对React.Fragment的元素，这样就不用额外创建用于包裹的元素</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 完全写法
render(){
    return(
        &lt;React.Fragment&gt;
            hello React
        &lt;/React.Fragment&gt;
    )
}

// 缩略写法
render(){
    return(
        &lt;&gt;
            hello React
        &lt;/&gt;
    )
}
</code></pre></div><h2 id="react-createelement"><a href="#react-createelement" aria-hidden="true" class="header-anchor">#</a> React.createElement</h2> <ul><li>创建react对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>React.createElement(
  type,
  [props],
  [...children]
);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class Hello extends React.Component {
  render() {
    return React.createElement('div', null, `Hello ${this.props.toWhat}`);
  }
}

ReactDOM.render(
  React.createElement(Hello, {toWhat: 'World'}, null),
  document.getElementById('root')
);
</code></pre></div><h2 id="react-createfactory"><a href="#react-createfactory" aria-hidden="true" class="header-anchor">#</a> React.createFactory</h2> <ul><li>返回一个React元素的函数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>React.createFactory({
  type,
  [props],
  [...children]
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function createFactory() {
  const li = React.createFactory('li');
  const Child1 = li(null, 'child-1');
  const Child2 = li(null, 'child-2');

  const Root = React.createElement('ul', '', Child1, Child2);

  return (
    &lt;Fieldset title='createFactory'&gt;
      {Root}
    &lt;/Fieldset&gt;
  );
}
</code></pre></div><h2 id="react-cloneelement"><a href="#react-cloneelement" aria-hidden="true" class="header-anchor">#</a> React.cloneElement</h2> <ul><li>克隆并返回一个新的React元素</li></ul> <div class="language- extra-class"><pre class="language-text"><code>React.cloneElement({
    type,
    [props],
    [...children]
})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class C extends React.Component {
  render(){
    var D = React.createElement('div');
    return React.cloneElement(
      D,
      null,
      'hello React'
    );
  }
}
</code></pre></div><h2 id="react-forwordref-props-ref"><a href="#react-forwordref-props-ref" aria-hidden="true" class="header-anchor">#</a> React.forwordRef(props,ref)</h2> <p><code>TODO @jingwen 需要独立文章分析</code></p> <ul><li>引用转发ref给组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>React.forwordRef(props,ref)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 简单用法
function Input(props) {
  const {forwardRef} = props;
  return (
    &lt;input type='input' defaultValue='输入框' ref={forwardRef} /&gt;
  );
};
Input.propTypes = {
  forwardRef: propTypes.object,
};
Input.defaultProps={
  forwardRef: {},
};

class ForwardRefComponent extends Component {
  constructor() {
    super();
    this.state = {
      refs: React.createRef(),
    };
  }

  handleFocus() {
    const {refs: {current}} = this.state;
    current.focus();
  }

  render() {
    const {refs} = this.state;
    const FancyInput = React.forwardRef((props, ref)=&gt;{
      return &lt;Input forwardRef={ref} /&gt;;
    });

    return (
      &lt;Fieldset title='forwardRef-简单用法'&gt;
        &lt;FancyInput ref={refs} /&gt;
        &lt;input type='button' value='获取焦点' onClick={()=&gt;this.handleFocus()} /&gt;
      &lt;/Fieldset&gt;
    );
  }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 转发ref给后代
function wrapped(Component) {
  class Wrapped extends React.Component {
    render() {
      const {forwardedRef, ...props} = this.props;
      return &lt;Component ref={forwardedRef} {...props} /&gt;;
    }
  }
  return React.forwardRef((props, ref) =&gt; {
    return &lt;Wrapped {...props} forwardedRef={ref} /&gt;;
  });
}

class Input extends React.Component {
  constructor(props) {
    super(props);
    this.ref = React.createRef();
  };

  handleFocus() {
    const {current} = this.ref;
    current.focus();
  }

  render() {
    const props = this.props;
    return (
      &lt;input type='input' defaultValue={props.value} ref={this.ref} /&gt;
    );
  }
}

class Hoc extends React.Component {
  constructor() {
    super();
    this.state = {
      refs: React.createRef(),
    };
  };

  handleFocus() {
    const {refs: {current}} = this.state;
    current.handleFocus();
  }

  render() {
    const {refs} = this.state;
    const InputHoc = wrapped(Input);

    return (
      &lt;Fieldset title='forwardRef-hoc-用法'&gt;
        &lt;InputHoc value='forwardRef-hoc-用法' ref={refs} /&gt;
        &lt;input type='button' value='获取焦点' onClick={()=&gt;this.handleFocus()} /&gt;
      &lt;/Fieldset&gt;
    );
  }
};
</code></pre></div><h2 id="react-lazy-or-react-suspense"><a href="#react-lazy-or-react-suspense" aria-hidden="true" class="header-anchor">#</a> React.lazy or React.Suspense</h2> <ul><li>React.lazy，动态导入组件</li> <li>React.Suspense，等待导入时的显示</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const TimeFun = lazy(()=&gt; import('./TimeFun'));
const TimeClass = lazy(()=&gt; import('./TimeClass'));

class Index extends Component {
  render() {
    const Time = new Date().toString();
    return (
      &lt;Fieldset title='lazy'&gt;
      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
        &lt;p&gt;parent: {Time}&lt;/p&gt;
        &lt;TimeFun /&gt;
        &lt;TimeClass /&gt;
      &lt;/Suspense&gt;
      &lt;/Fieldset&gt;
    );
  }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>class TimeClass extends React.Component {
  render() {
    const Time = new Date().toString();
    return &lt;div&gt;lazy-time-class: {Time}&lt;/div&gt;;
  };
};

export default TimeClass;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function TimeFun() {
  const Time = new Date().toString();
  return (&lt;div&gt;lazy-time-fun: {Time}&lt;/div&gt;);
};

export default TimeFun;
</code></pre></div><h2 id="react-strictmode"><a href="#react-strictmode" aria-hidden="true" class="header-anchor">#</a> React.StrictMode</h2> <ul><li>给组件的任何部分开启严格模式</li> <li>识别具有不安全生命周期的组件</li> <li>关于遗留字符串ref API使用的警告</li> <li>关于已弃用的findDOMNode用法的警告</li> <li>检测意外的副作用</li> <li>检测遗留上下文API</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends Component {
  render() {
    return (
      &lt;Fieldset title='StrictMode'&gt;
        &lt;StrictMode&gt;
          StrictMode
        &lt;/StrictMode&gt;
      &lt;/Fieldset&gt;
    );
  }
};
</code></pre></div><h2 id="context"><a href="#context" aria-hidden="true" class="header-anchor">#</a> Context</h2> <ul><li>组件设置全局参数</li> <li>createContext，设置context的默认值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const A = React.createContext('aaaa');
</code></pre></div><ul><li>Context.Provider，允许组件订阅该context的参数</li> <li>Class.contextType，设置当前组件订阅的context。当找不到Provider的时候使用。context值可以在componentDidMount、componentUpdate、componentWillUnmount、render中获取</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
// 两种设置形式
const context = React.createContext('aaa');
class A extend React.Component{
    static contextType = context;
}

class B extend React.Component{

}
B.contextType = context;
</code></pre></div><ul><li>Context.Consumer，</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 简单例子
const ThemeContext = React.createContext('light');

class ThemedButton extends React.Component {
  static contextType = ThemeContext;
  render() {
    return &lt;input defaultValue={this.context} type='input' /&gt;;
  }
}

function Toolbar(props) {
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

class Index extends Component {
  render() {
    return (
      &lt;Fieldset title='context'&gt;
        &lt;Toolbar /&gt;
        &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
          &lt;Toolbar /&gt;
        &lt;/ThemeContext.Provider&gt;
      &lt;/Fieldset&gt;
    );
  }
}
</code></pre></div><ul><li>Consumer，设置多个上下文</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const themes = {
  light: {
    background: '#eeeeee',
  },
  dark: {
    background: '#222222',
  },
};

const ThemeContext = createContext(
  themes.light,
);

class ThemeButton extends Component {
  static contextType = ThemeContext;
  render() {
    const props = this.props;
    const theme = this.context;
    return (
      &lt;button type='button' {...props} style={{backgroundColor: theme.background}} &gt;
        Theme
      &lt;/button&gt;
    );
  }
};

class Index extends Component {
  constructor(props) {
    super(props);
    this.state = {
      theme: themes.light,
    };
  }

  handleTheme() {
    this.setState((state)=&gt;({
      theme: JSON.stringify(state.theme) === JSON.stringify(themes.dark)
        ? themes.light
        : themes.dark,
    }));
  };

  render() {
    return (
      &lt;Fieldset title='多context'&gt;
        &lt;ThemeContext.Provider value={this.state.theme}&gt;
          &lt;ThemeButton onClick={()=&gt;this.handleTheme()}&gt;
            Change Theme
          &lt;/ThemeButton&gt;
        &lt;/ThemeContext.Provider&gt;
        &lt;ThemeButton /&gt;
      &lt;/Fieldset&gt;
    );
  }
}
</code></pre></div><h2 id="reactdom-createportal"><a href="#reactdom-createportal" aria-hidden="true" class="header-anchor">#</a> ReactDOM.createPortal</h2> <div class="language- extra-class"><pre class="language-text"><code>ReactDOM.createPortal(
    React.Component | JSX, // react组件
    element,// 节点元素
);
</code></pre></div><h2 id="defaultprops"><a href="#defaultprops" aria-hidden="true" class="header-anchor">#</a> defaultProps</h2> <ul><li>设置props的默认值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>class A extends React.Component{
    constructor(props){
        super(props);
        console.log(props)
    };
    
    // 集成写法
    static defaultProps = {
        test: 'test',        
    };
}

// 外置写法
A.defaultPorps = {
    test: 'test',
}
</code></pre></div><h2 id="proptypes"><a href="#proptypes" aria-hidden="true" class="header-anchor">#</a> PropTypes</h2> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><h1 id="render-props"><a href="#render-props" aria-hidden="true" class="header-anchor">#</a> Render Props</h1> <ul><li>解决组件交叉使用问题</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Cat(props) {
  const STYLE = {
    width: 20,
    height: 20,
    background: '#FF00FF',
    position: 'absolute',
    left: props.mouse.x,
    top: props.mouse.y,
  };

  return (
    &lt;div style={STYLE} /&gt;
  );
}
Cat.propTypes = {
  mouse: propTypes.object.isRequired,
};

class Mouse extends Component {
  constructor(props) {
    super(props);
    this.state={
      x: 0,
      y: 0,
    };
  }

  handleMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY,
    });
  };

  render() {
    const STYLE = {
      width: 500,
      height: 500,
      background: '#eee',
      display: 'inline-block',
    };

    return (
      &lt;div style={STYLE} onMouseMove={(e)=&gt;this.handleMove(e)}&gt;
        {this.props.render(this.state)}
      &lt;/div&gt;
    );
  }
}
Mouse.propTypes = {
  render: propTypes.func.isRequired,
};

class Index extends Component {
  render() {
    return (
      &lt;Fieldset title='render props'&gt;
        &lt;Mouse render={(mouse)=&gt;(
          &lt;Cat mouse={mouse} /&gt;
        )} /&gt;
      &lt;/Fieldset&gt;
    );
  }
};
</code></pre></div><h1 id="react的事件池"><a href="#react的事件池" aria-hidden="true" class="header-anchor">#</a> React的事件池</h1> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><h1 id="hooks"><a href="#hooks" aria-hidden="true" class="header-anchor">#</a> Hooks</h1> <h2 id="usestate-状态钩"><a href="#usestate-状态钩" aria-hidden="true" class="header-anchor">#</a> useState 状态钩</h2> <ul><li>用来设置和更新状态</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const [状态变量,更新函数] = useState(默认值)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function A(){
  const [count, setCount] = useState(0);

  return(
    &lt;React.Fragment&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={()=&gt;{setCount(count+1)}}&gt;++&lt;/button&gt;
      &lt;button onClick={()=&gt;{setCount(count-1)}}&gt;--&lt;/button&gt;
    &lt;/React.Fragment&gt;
  )
};
</code></pre></div><h2 id="useeffect-function-效果钩"><a href="#useeffect-function-效果钩" aria-hidden="true" class="header-anchor">#</a> useEffect(function,[]) 效果钩</h2> <div class="language- extra-class"><pre class="language-text"><code>useEffect(()=&gt;{
    // componentDidMount
    // componentDidUpdate
    return ()=&gt;{
        // componentWillUnmount
    }
},[]);
</code></pre></div><ul><li>useEffect是componentDidMount、componentDidUpdate、componentWillUnmount的结合。</li> <li>默认情况下，useEffect，会在每次componentDidMount、componentDidUpdate时执行。</li> <li>可以拿到DOM结构</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function A(){
  const [count,setCount] = useState(0)

  useEffect(()=&gt;{
    document.getElementById('useEffect-A-count').innerText = `count: ${count}`;
  });

  function handleClick(){
    setCount(count+1);
  };

  return (
    &lt;Fieldset title='useEffect-简单状态'&gt;
      &lt;p id='useEffect-A-count'&gt;&lt;/p&gt;
      &lt;input type='button' value='更新' onClick={handleClick}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><ul><li>如何在组件compoenntWillUnmount时触发useEffect</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function B(){
  const [show,setShow] = useState(true);
  function Child(){
    useEffect(()=&gt;{
      console.log('componentDidMount');
      return ()=&gt;{
        console.log('componentWillUnmount');
      }
    })
    return &lt;p&gt;B-Child&lt;/p&gt;
  };

  return (
    &lt;Fieldset title='useEffect-在componentWillUnmunt时触发'&gt;
      &lt;p&gt;请查看log&lt;/p&gt;
      &lt;input type='button' value='show' onClick={()=&gt;setShow(!show)}/&gt;
      {show &amp;&amp; &lt;Child/&gt;}
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><ul><li>利用第二个参数，让useEffect不会过度渲染</li> <li>为空数组，表示不依赖props或者state，将不会更新</li> <li>数组内表示当新的赋值，如果新值和旧值不想等，就更新</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function D(){
  const [count,setCount] = useState(0);
  const [double,setDouble] = useState(count*2);
  const [three,setThree] = useState(count*3);
  
  useEffect(()=&gt;{
    setDouble(count*2);
  },[count*2])

  useEffect(()=&gt;{
    setThree(count);
  },[])// 为空数组，表示不依赖props或者state，将不会更新

  return (
    &lt;Fieldset title='userEffect-利用第二个参数跳过效果优化'&gt;
      &lt;p&gt;+1: {count}&lt;/p&gt;
      &lt;p&gt;*2: {double}&lt;/p&gt;
      &lt;p&gt;not: {three}&lt;/p&gt;
      &lt;input type='button' value='click' onClick={()=&gt;setCount(count+1)}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h2 id="uselayouteffect-function"><a href="#uselayouteffect-function" aria-hidden="true" class="header-anchor">#</a> useLayoutEffect(function,[])</h2> <ul><li>DOM渲染前反应的钩子</li> <li>基本配置和useEffect一致</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function E(){
  const [name,setName] = useState(null);
  useLayoutEffect(()=&gt;{
    setTimeout(()=&gt;{
      setName('useLayoutEffect');
    },3000);
  },[]);
  useEffect(()=&gt;{
    setTimeout(()=&gt;{
      setName('useEffect');
    },3000);
  },[]);

  return(
    &lt;Fieldset title='useLayoutEffecth和useEffect的区别'&gt;
      &lt;span id='e-useEffect'&gt;{name}&lt;/span&gt;
    &lt;/Fieldset&gt;
  )
}
</code></pre></div><h2 id="usecontext-createcontext"><a href="#usecontext-createcontext" aria-hidden="true" class="header-anchor">#</a> useContext(createContext)</h2> <ul><li>参数在所有子组件中都能获取</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const CountContext = createContext();
function F(){
  function ChildA(){
    const countChild = useContext(CountContext);
    return (
      &lt;p&gt;
        Child A count: {countChild}
      &lt;/p&gt;
    )
  };

  function ChildB(){
    const countChild = useContext(CountContext);
    return (
      &lt;p&gt;
        Child B count: {countChild}
      &lt;/p&gt;
    )
  };

  const [count,setCount] = useState(0);

  return (
    &lt;Fieldset title='useContext'&gt;
      &lt;CountContext.Provider value={count}&gt;
        &lt;ChildA /&gt;
        &lt;ChildB /&gt;
      &lt;/CountContext.Provider&gt;
      &lt;input type='button' value='++' onClick={()=&gt;setCount(count+1)}/&gt;
    &lt;/Fieldset&gt;
  )
}
</code></pre></div><h2 id="usereducer-reducer-initialstate"><a href="#usereducer-reducer-initialstate" aria-hidden="true" class="header-anchor">#</a> useReducer(reducer,initialState)</h2> <ul><li>类似redux的功能</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const [state,dispatch] = useReducer(reducer,initialState,{action});
// const [属性,动作] = useReducer(动作函数,初始值属性,初始动作);
// 如何触发：dispatch(type);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function reducer(state,action){
  switch(action){
    case 'reset':
      return 0;
      break;
    case 'increment':
      return state+1;
      break;
    case 'decrement':
      return state-1;
      break;
    default:
      return state;
  };
};

function useReduceComponent(){
  const [state,dispatch] = useReducer(reducer,0,'reset');

  return (
    &lt;Fieldset title='useReduce'&gt;
      &lt;p&gt;{state}&lt;/p&gt;
      &lt;input type='button' value='++' onClick={()=&gt;dispatch('increment')}/&gt;
      &lt;input type='button' value='--' onClick={()=&gt;dispatch('decrement')}/&gt;
      &lt;input type='button' value='reset' onClick={()=&gt;dispatch('reset')}/&gt;
    &lt;/Fieldset&gt;
  );
};
</code></pre></div><h2 id="usecallback"><a href="#usecallback" aria-hidden="true" class="header-anchor">#</a> useCallback(()=&gt;{},[])</h2> <ul><li>返回一个记忆的memoized，默认情况下会记录上一次传递的值</li> <li>可以替代shouldComponentUpdate使用</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function MemoizedConst ({num}){
  const memoizedCallback = useCallback(()=&gt;{
    return num;
  },[]);

  return (
    &lt;Fieldset title='MemoizedConst'&gt;
      &lt;p&gt;记忆 num &gt; {memoizedCallback()}&lt;/p&gt;
      &lt;p&gt;原始 num &gt; {num}&lt;/p&gt;
    &lt;/Fieldset&gt;
  )
};

function UseCallbackComponent (){
  let [num,setNum] = useState([1,2,3]);
  useEffect(()=&gt;{
    setTimeout(function(){
      setNum([3,4,5])
    },3000);
  },[]);
  
  return (
    &lt;Fieldset title='useCallback'&gt;
      &lt;MemoizedConst num={num}/&gt;
    &lt;/Fieldset&gt;
  );
};

// [1,2,3]
// dely 3000ms
// [3,4,5]
</code></pre></div><ul><li>保存事件，让组件不会重复创建新方法，当你重复点击时，InputComponentState的handleClick的事件总是由组件新创建的。而InputComponentCallback的handleClick会被记忆下来，不会新创建。有利于提高性能。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let InputComponentStateFunc = null;
function InputComponentState(){
  const [state,setState] = useState(0);
  function handleClick(){
    setState(state=&gt; state+1);
  };
  
  console.group('InputComponentStateFunc');
    console.log(InputComponentStateFunc === handleClick);
  console.groupEnd();

  InputComponentStateFunc = handleClick;

  return (
    &lt;Fieldset title='InputComponentState'&gt;
      &lt;input type='button' value={state} onClick={handleClick}/&gt;
    &lt;/Fieldset&gt;
  )
};

let InputComponentCallbackFunc = null;
function InputComponentCallback(){
  const [state,setState] = useState(0);
  const handleClick = useCallback((event) =&gt; {
    setState(state=&gt; state+1);
    event.persist();
  },[]);
  
  console.group('InputComponentCallbackFunc');
    console.log(InputComponentCallbackFunc === handleClick);
  console.groupEnd();
  
  InputComponentCallbackFunc = handleClick;

  return (
    &lt;Fieldset title='InputComponentCallback'&gt;
      {}
      &lt;input type='button' value={state} onClick={handleClick}/&gt;
    &lt;/Fieldset&gt;
  )
};

function UseCallbackComponent (){
  return (
    &lt;Fieldset title='useCallback'&gt;
      &lt;InputComponentState /&gt;
      &lt;InputComponentCallback /&gt;
    &lt;/Fieldset&gt;
  );
};
</code></pre></div><h2 id="usememo-function"><a href="#usememo-function" aria-hidden="true" class="header-anchor">#</a> useMemo(function,[])</h2> <ul><li>和useCallback基本一致，我还没发现有什么区别Q。Q</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function MemoizedLet({num}){
  const memo = useMemo(()=&gt; num,[]);

  return (
    &lt;Fieldset title='MemoizedLet'&gt;
      &lt;p&gt;记忆 num &gt; {memo}&lt;/p&gt;
      &lt;p&gt;原始 num &gt; {num}&lt;/p&gt;
    &lt;/Fieldset&gt;
  )
};

function MemoizedConst({num}){
  const memo = useMemo(()=&gt; num,[num]);

  return (
    &lt;Fieldset title='MemoizedConst'&gt;
      &lt;p&gt;记忆 num &gt; {memo}&lt;/p&gt;
      &lt;p&gt;原始 num &gt; {num}&lt;/p&gt;
    &lt;/Fieldset&gt;
  )
};

function useMemoComponent(){
  const [num,setNum] = useState([1,2,3]);

  useEffect(()=&gt;{
    setTimeout(()=&gt;{
      setNum([3,4,5]);
    },3000);
  },[]);

  return (
    &lt;Fieldset title='useMemoComponent'&gt;
      &lt;MemoizedLet num={num} /&gt;
      &lt;MemoizedConst num={num}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h2 id="useref"><a href="#useref" aria-hidden="true" class="header-anchor">#</a> useRef()</h2> <ul><li>返回一个ref对象，这个对象将维持在组件的整个生命周期</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function useRefComponent(){
  const inputEl = useRef(null);
  
  function handleClick(){
    inputEl.current.focus();
  }
  return(
    &lt;Fieldset title='useRef'&gt;
      &lt;input type='input' placeholder='useRef' ref={inputEl} /&gt;
      &lt;input type='button' value='获取焦点' onClick={handleClick} /&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h2 id="useimperativemethods-ref"><a href="#useimperativemethods-ref" aria-hidden="true" class="header-anchor">#</a> useImperativeMethods(ref,()=&gt;({}))</h2> <ul><li>向父组件公开ref实例</li> <li>只能应用于forwardRef(props,ref)</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function FancyInput(props,ref){
  const inputRef = useRef(null);
  useImperativeMethods(ref,()=&gt;({
    focus: ()=&gt;{
      inputRef.current.focus();
    }
  }));

  return &lt;input type='input' placeholder='useRef' ref={inputRef}/&gt;
};

const Input = forwardRef(FancyInput);

function UseImperativeMethodsComponent(){
  const fancyInputRef = useRef(null);
  function handleClick(){
    fancyInputRef.current.focus();
  };

  return (
    &lt;Fieldset title='UseImperativeMethods'&gt;
      &lt;Input ref={fancyInputRef}/&gt;
      &lt;input type='button' value='获取焦点' onClick={handleClick}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h2 id="usemutationeffect-function"><a href="#usemutationeffect-function" aria-hidden="true" class="header-anchor">#</a> useMutationEffect(function,[])</h2> <ul><li>和useEffect、useLayoutEffect类似</li> <li>useMutationEffect会在更新阶段触发</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Effect(){
  const [state,setState] = useState('请看log')
  useEffect(()=&gt;{
    setTimeout(()=&gt;{
      console.log('useEffect');
    });
  },[]);

  useLayoutEffect(()=&gt;{
    setTimeout(()=&gt;{
      console.log('useLayoutEffect');
    });
  },[]);

  useMutationEffect(()=&gt;{
    setTimeout(()=&gt;{
      console.log('useMutationEffect');
    });
  },[]);

  return (
    &lt;React.Fragment&gt;
      {state}
    &lt;/React.Fragment&gt;
  )
}

function useMutationEffectComponent(){
  const [show,setShow] = useState(false);
  return (
    &lt;Fieldset title='useMutationEffect'&gt;
      { show &amp;&amp; &lt;Effect /&gt;}
      &lt;input type='button' value='show' onClick={()=&gt;setShow(!show)}/&gt;
    &lt;/Fieldset&gt;
  )
};
</code></pre></div><h1 id="hoc-高级组件"><a href="#hoc-高级组件" aria-hidden="true" class="header-anchor">#</a> HOC 高级组件</h1> <p>解释</p> <ul><li>一个参数为React组件的函数，并且返回一个新函数，一个类工厂。</li></ul> <p>优点</p> <ul><li>高内聚，低耦合</li> <li>代码复用，高度模块化</li></ul> <p>基本用途</p> <ul><li>增删改props</li> <li>渲染劫持</li></ul> <p>公式</p> <div class="language- extra-class"><pre class="language-text"><code>React.Component function WrappedComponent(React.Component:Component)
</code></pre></div><p>简单例子</p> <div class="language- extra-class"><pre class="language-text"><code>function WrappedComponent(Wrapped){
  return class extends React.Component{
    render(){
      const props = {
        context: 'React',
      }
      return &lt;Wrapped {...props}/&gt;;
    }
  }
};

class Child extends React.Component{
  render(){return &lt;div&gt;hello {this.props.context}&lt;/div&gt;};
};

class App extends React.Component{
  render(){
    const HOCchild = WrappedComponent(Child);
    
    return(
      &lt;div&gt;
        &lt;h1&gt;App&lt;/h1&gt;
        &lt;HOCchild /&gt;
      &lt;/div&gt;
    )
  }
};
</code></pre></div><p>注意</p> <ul><li>不要改变原始组件，使用组合的形式</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 错误示范
// WrappedComponent 中会覆盖组件的componentDidMount方法
// 而且使用者必须要知道被覆盖方法的具体用途，才能避免方法冲突覆盖

function WrappedComponent(Wrapped) {
  Wrapped.prototype.componentDidMount = ()=&gt;{
    console.log('WrappedComponent');
  };

  return Wrapped;
};

class Child extends React.Component{
  componentDidMount(){
    console.log('Child');
  }
  render(){return &lt;div&gt;hello React&lt;/div&gt;};
};

class App extends React.Component{
  render(){
    const HOCchild = WrappedComponent(Child);

    return(
      &lt;React.Fragment&gt;
        &lt;HOCchild /&gt;
      &lt;/React.Fragment&gt;
    )
  }
};
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 正确示范
function wrappedComponent(Wrapped){
    return class React.Component{
        componentDibMount(){
            console.log('componentDibMount')
        }
    };
};
</code></pre></div><ul><li>不要直接修改HOC的props，最好独立变量</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 错误示范
// props中可能包含太多多余的属性，无法确保高阶组件的灵活度和可重用性
function WrappedComponent(Wrapped){
    return class React.Component{
        return &lt;Wrapped {...this.props}/&gt;
    }
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 正确
function WrappedComponent(Wrapped){
    return class React.Component{
        const {detail} = this.props;
        return &lt;Wrapped {...detail} /&gt;
    }
}
</code></pre></div><ul><li>包装显示名称，便于调试</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function WrappedComponent(Wrapped){
  class WithSubscription extends React.Component{
    componentDidMount(){
      console.log('WrappedComponent');
    }
    render(){return &lt;Wrapped/&gt;}
  };

  function getDiplayName(W){
    return W.displayName || W.name || 'Component';
  }

  WithSubscription.displayName = `WithSubscription(${getDiplayName(Wrapped)})`

  return WithSubscription;
};
</code></pre></div><ul><li>不要在render函数中使用高阶组件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><ul><li>必须将静态方法做拷贝</li></ul> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><ul><li>Refs属性不能传递</li></ul> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><h1 id="无es6创建react-component"><a href="#无es6创建react-component" aria-hidden="true" class="header-anchor">#</a> 无ES6创建React Component</h1> <ul><li>create-react-class</li></ul> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><h1 id="动态引入-dynamic-import"><a href="#动态引入-dynamic-import" aria-hidden="true" class="header-anchor">#</a> 动态引入 dynamic import</h1> <ul><li>React Loadable</li></ul> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div><h1 id="受控制组件-or-非受控制组件"><a href="#受控制组件-or-非受控制组件" aria-hidden="true" class="header-anchor">#</a> 受控制组件 or 非受控制组件</h1> <div class="language- extra-class"><pre class="language-text"><code>TODO
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs-interview/assets/js/app.95d31192.js" defer></script><script src="/docs-interview/assets/js/2.387e38e1.js" defer></script><script src="/docs-interview/assets/js/16.d53c70f1.js" defer></script>
  </body>
</html>
