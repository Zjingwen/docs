<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>高质量的React组件 | 伪公知的生活常态</title>
    <meta name="description" content="就是随便写写而已">
    
    
    <link rel="preload" href="/doc/assets/css/0.styles.fd39fceb.css" as="style"><link rel="preload" href="/doc/assets/js/app.37ba04a1.js" as="script"><link rel="preload" href="/doc/assets/js/2.387e38e1.js" as="script"><link rel="preload" href="/doc/assets/js/11.a1378e1b.js" as="script"><link rel="prefetch" href="/doc/assets/js/10.5f5b6b11.js"><link rel="prefetch" href="/doc/assets/js/100.26536cc9.js"><link rel="prefetch" href="/doc/assets/js/101.ef604d61.js"><link rel="prefetch" href="/doc/assets/js/102.7713deb6.js"><link rel="prefetch" href="/doc/assets/js/103.b877dd42.js"><link rel="prefetch" href="/doc/assets/js/104.ba65479e.js"><link rel="prefetch" href="/doc/assets/js/105.6e5b3780.js"><link rel="prefetch" href="/doc/assets/js/106.89a21ec7.js"><link rel="prefetch" href="/doc/assets/js/107.0c04e9d8.js"><link rel="prefetch" href="/doc/assets/js/108.d49a0e1d.js"><link rel="prefetch" href="/doc/assets/js/109.8fa00ff0.js"><link rel="prefetch" href="/doc/assets/js/110.eb0cdcaa.js"><link rel="prefetch" href="/doc/assets/js/111.5d84d049.js"><link rel="prefetch" href="/doc/assets/js/112.608d6c0a.js"><link rel="prefetch" href="/doc/assets/js/113.a201a826.js"><link rel="prefetch" href="/doc/assets/js/114.ea5d1700.js"><link rel="prefetch" href="/doc/assets/js/115.055b1b5d.js"><link rel="prefetch" href="/doc/assets/js/116.4cabfb7a.js"><link rel="prefetch" href="/doc/assets/js/117.b866a639.js"><link rel="prefetch" href="/doc/assets/js/118.67cf21a2.js"><link rel="prefetch" href="/doc/assets/js/119.4d720e0a.js"><link rel="prefetch" href="/doc/assets/js/12.cd6ab88c.js"><link rel="prefetch" href="/doc/assets/js/120.b6420200.js"><link rel="prefetch" href="/doc/assets/js/121.f62c4740.js"><link rel="prefetch" href="/doc/assets/js/122.2e228b20.js"><link rel="prefetch" href="/doc/assets/js/123.ee925db9.js"><link rel="prefetch" href="/doc/assets/js/124.cbb6d23a.js"><link rel="prefetch" href="/doc/assets/js/125.71f51813.js"><link rel="prefetch" href="/doc/assets/js/126.8001dc97.js"><link rel="prefetch" href="/doc/assets/js/127.0a8c3722.js"><link rel="prefetch" href="/doc/assets/js/128.e0b123f2.js"><link rel="prefetch" href="/doc/assets/js/129.37fbcde0.js"><link rel="prefetch" href="/doc/assets/js/13.147fffe4.js"><link rel="prefetch" href="/doc/assets/js/130.3c8e90ee.js"><link rel="prefetch" href="/doc/assets/js/131.86053ffc.js"><link rel="prefetch" href="/doc/assets/js/132.e4e5ad61.js"><link rel="prefetch" href="/doc/assets/js/133.f3f8534a.js"><link rel="prefetch" href="/doc/assets/js/134.655fd8ee.js"><link rel="prefetch" href="/doc/assets/js/135.c110e3ec.js"><link rel="prefetch" href="/doc/assets/js/136.0b92fdd6.js"><link rel="prefetch" href="/doc/assets/js/137.5ccea8b1.js"><link rel="prefetch" href="/doc/assets/js/138.b2eae4d6.js"><link rel="prefetch" href="/doc/assets/js/139.a4983d50.js"><link rel="prefetch" href="/doc/assets/js/14.51dd794f.js"><link rel="prefetch" href="/doc/assets/js/140.09b4b5e7.js"><link rel="prefetch" href="/doc/assets/js/141.6165faab.js"><link rel="prefetch" href="/doc/assets/js/142.20b8ce46.js"><link rel="prefetch" href="/doc/assets/js/143.5a613b9f.js"><link rel="prefetch" href="/doc/assets/js/144.0573c750.js"><link rel="prefetch" href="/doc/assets/js/15.08a3298b.js"><link rel="prefetch" href="/doc/assets/js/16.31109dad.js"><link rel="prefetch" href="/doc/assets/js/17.9486ef0a.js"><link rel="prefetch" href="/doc/assets/js/18.5e017411.js"><link rel="prefetch" href="/doc/assets/js/19.446dab5a.js"><link rel="prefetch" href="/doc/assets/js/20.fd6f58e6.js"><link rel="prefetch" href="/doc/assets/js/21.c64790f1.js"><link rel="prefetch" href="/doc/assets/js/22.201393b9.js"><link rel="prefetch" href="/doc/assets/js/23.a2c2a19a.js"><link rel="prefetch" href="/doc/assets/js/24.90392722.js"><link rel="prefetch" href="/doc/assets/js/25.8b23013a.js"><link rel="prefetch" href="/doc/assets/js/26.cf397d24.js"><link rel="prefetch" href="/doc/assets/js/27.1da5c841.js"><link rel="prefetch" href="/doc/assets/js/28.26fca84b.js"><link rel="prefetch" href="/doc/assets/js/29.5ed5fff9.js"><link rel="prefetch" href="/doc/assets/js/3.e24aff58.js"><link rel="prefetch" href="/doc/assets/js/30.144367d7.js"><link rel="prefetch" href="/doc/assets/js/31.12cfe647.js"><link rel="prefetch" href="/doc/assets/js/32.5107626d.js"><link rel="prefetch" href="/doc/assets/js/33.02053b5b.js"><link rel="prefetch" href="/doc/assets/js/34.5e62f8a4.js"><link rel="prefetch" href="/doc/assets/js/35.63c58f1e.js"><link rel="prefetch" href="/doc/assets/js/36.06f274ed.js"><link rel="prefetch" href="/doc/assets/js/37.ea004859.js"><link rel="prefetch" href="/doc/assets/js/38.d3d9c594.js"><link rel="prefetch" href="/doc/assets/js/39.c5af91c3.js"><link rel="prefetch" href="/doc/assets/js/4.e2e0255b.js"><link rel="prefetch" href="/doc/assets/js/40.d48fe4bb.js"><link rel="prefetch" href="/doc/assets/js/41.b2215e85.js"><link rel="prefetch" href="/doc/assets/js/42.6ecc20b2.js"><link rel="prefetch" href="/doc/assets/js/43.d48d7214.js"><link rel="prefetch" href="/doc/assets/js/44.f56d3e66.js"><link rel="prefetch" href="/doc/assets/js/45.7c5d2214.js"><link rel="prefetch" href="/doc/assets/js/46.cad73163.js"><link rel="prefetch" href="/doc/assets/js/47.3a25ff94.js"><link rel="prefetch" href="/doc/assets/js/48.98d159e1.js"><link rel="prefetch" href="/doc/assets/js/49.fe28623a.js"><link rel="prefetch" href="/doc/assets/js/5.cd3fd4c9.js"><link rel="prefetch" href="/doc/assets/js/50.f2d2864e.js"><link rel="prefetch" href="/doc/assets/js/51.3e9ede3a.js"><link rel="prefetch" href="/doc/assets/js/52.ca7b5f42.js"><link rel="prefetch" href="/doc/assets/js/53.b47bf86d.js"><link rel="prefetch" href="/doc/assets/js/54.6a2cbaf5.js"><link rel="prefetch" href="/doc/assets/js/55.91582a90.js"><link rel="prefetch" href="/doc/assets/js/56.f86be0ea.js"><link rel="prefetch" href="/doc/assets/js/57.9736ae8a.js"><link rel="prefetch" href="/doc/assets/js/58.6733876e.js"><link rel="prefetch" href="/doc/assets/js/59.a4a0f2df.js"><link rel="prefetch" href="/doc/assets/js/6.7f28e2d3.js"><link rel="prefetch" href="/doc/assets/js/60.f55b6cb7.js"><link rel="prefetch" href="/doc/assets/js/61.ee9258ec.js"><link rel="prefetch" href="/doc/assets/js/62.d919aadf.js"><link rel="prefetch" href="/doc/assets/js/63.52fea91c.js"><link rel="prefetch" href="/doc/assets/js/64.1e084768.js"><link rel="prefetch" href="/doc/assets/js/65.bb395bbf.js"><link rel="prefetch" href="/doc/assets/js/66.bd6896bd.js"><link rel="prefetch" href="/doc/assets/js/67.37657eee.js"><link rel="prefetch" href="/doc/assets/js/68.d823ca9e.js"><link rel="prefetch" href="/doc/assets/js/69.0f13b4d0.js"><link rel="prefetch" href="/doc/assets/js/7.5ada4c1f.js"><link rel="prefetch" href="/doc/assets/js/70.2c1ecb69.js"><link rel="prefetch" href="/doc/assets/js/71.6aee0b5d.js"><link rel="prefetch" href="/doc/assets/js/72.70289cf9.js"><link rel="prefetch" href="/doc/assets/js/73.b426c2bb.js"><link rel="prefetch" href="/doc/assets/js/74.00b3e003.js"><link rel="prefetch" href="/doc/assets/js/75.ccc6fa42.js"><link rel="prefetch" href="/doc/assets/js/76.270f4c28.js"><link rel="prefetch" href="/doc/assets/js/77.c0806518.js"><link rel="prefetch" href="/doc/assets/js/78.f145e4e5.js"><link rel="prefetch" href="/doc/assets/js/79.d8362f0f.js"><link rel="prefetch" href="/doc/assets/js/8.345a0ef7.js"><link rel="prefetch" href="/doc/assets/js/80.f94e0231.js"><link rel="prefetch" href="/doc/assets/js/81.94080aec.js"><link rel="prefetch" href="/doc/assets/js/82.bc659265.js"><link rel="prefetch" href="/doc/assets/js/83.d4d2767e.js"><link rel="prefetch" href="/doc/assets/js/84.e59df14e.js"><link rel="prefetch" href="/doc/assets/js/85.60f7cc9e.js"><link rel="prefetch" href="/doc/assets/js/86.02c79022.js"><link rel="prefetch" href="/doc/assets/js/87.cd092a77.js"><link rel="prefetch" href="/doc/assets/js/88.ce7120fa.js"><link rel="prefetch" href="/doc/assets/js/89.eca17faa.js"><link rel="prefetch" href="/doc/assets/js/9.631db003.js"><link rel="prefetch" href="/doc/assets/js/90.81085990.js"><link rel="prefetch" href="/doc/assets/js/91.1dc2aee4.js"><link rel="prefetch" href="/doc/assets/js/92.229f99c0.js"><link rel="prefetch" href="/doc/assets/js/93.b4169369.js"><link rel="prefetch" href="/doc/assets/js/94.fdf0a2cb.js"><link rel="prefetch" href="/doc/assets/js/95.1ae19c65.js"><link rel="prefetch" href="/doc/assets/js/96.11dbe007.js"><link rel="prefetch" href="/doc/assets/js/97.d17531e2.js"><link rel="prefetch" href="/doc/assets/js/98.c6c86090.js"><link rel="prefetch" href="/doc/assets/js/99.c0733e0b.js">
    <link rel="stylesheet" href="/doc/assets/css/0.styles.fd39fceb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/doc/" class="home-link router-link-active"><!----> <span class="site-name">伪公知的生活常态</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/doc/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/" class="sidebar-link">个人笔记</a></li><li><a href="/doc/%E6%94%B6%E8%97%8F%E7%AC%94%E8%AE%B0/" class="sidebar-link">收藏笔记</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="高质量的react组件"><a href="#高质量的react组件" aria-hidden="true" class="header-anchor">#</a> 高质量的React组件</h1> <p>[TOC]</p> <h2 id="如何拆分组件"><a href="#如何拆分组件" aria-hidden="true" class="header-anchor">#</a> 如何拆分组件</h2> <ul><li>确定组件边界</li> <li>组件都应该是独立存在的</li> <li>不同组件之间的通信交流</li> <li>满足高内聚和低耦合</li></ul> <h2 id="高内聚"><a href="#高内聚" aria-hidden="true" class="header-anchor">#</a> 高内聚</h2> <ul><li>把逻辑紧密相关的内容放一个组件</li> <li>展示内容用JSX、定义行为用javascript、定义样式用css</li> <li>React天生具有高内聚的特定</li></ul> <h2 id="低耦合"><a href="#低耦合" aria-hidden="true" class="header-anchor">#</a> 低耦合</h2> <ul><li>不同组件之间的依赖关系尽量弱化。</li> <li>根据功能点划分模块，让不同的组件去实现不同的功能。</li></ul> <h2 id="如何选择使用prop和state"><a href="#如何选择使用prop和state" aria-hidden="true" class="header-anchor">#</a> 如何选择使用prop和state</h2> <ul><li>prop和state都会引起组件的重新渲染</li> <li>prop是组件的对外接口</li> <li>state是组件的内部状态</li></ul> <h2 id="prop"><a href="#prop" aria-hidden="true" class="header-anchor">#</a> prop</h2> <ul><li>当prop的类型不是字符串类型时，在JSX中必须使用花括号<code>{}</code>把prop值包裹</li> <li>函数类型的prop等于让父组件交给子组件一个回调函数</li></ul> <h2 id="读取prop"><a href="#读取prop" aria-hidden="true" class="header-anchor">#</a> 读取prop</h2> <ul><li>在构造函数中调用<code>super(props)</code>，在组件实例渲染被构造之后，类实例的所有函数成员就可以通过<code>this.prop</code>访问到父组件传递过来的props值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>constructor(props){
    super(props);
    ...
}
</code></pre></div><h2 id="proptypes"><a href="#proptypes" aria-hidden="true" class="header-anchor">#</a> propTypes</h2> <ul><li>React.PropTypes 自 React v15.5 起已弃用，使用 prop-types 库代替</li> <li>限制组件支持哪些类型的prop</li> <li>限制每个prop应该是什么样的数据格式</li> <li>根据propTypes判断父组件是否正确地使用了组件的属性</li> <li>定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。开发者在代码中定义的propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码会更优</li></ul> <p>TODO不同验证器例子</p> <div class="language- extra-class"><pre class="language-text"><code>// 原生类型
PropTypes.array,// 数组类型
PropTypes.boll,// 布尔类型
PropTypes.func,// 函数类型
PropTypes.number,// 数字类型
PropTypes.object,// 对象类型
PropTypes.string,// 字符串类型
PropTypes.symbol,// 元祖类型

// 可被渲染的元素
PropTypes.node

// React元素
PropTypes.element

// 声明类实例
PropTypes.instanceOf(Message)

// 限定特定值
PropTypes.oneOf([option,...])

// 限定类型
PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message),
])

// 限定数组元素类型
PropTypes.arrayOf(PropTypes.number)

// 限定对象元素类型
PropTypes.objectOf(PropTypes.number)

// 限定对象属性以及类型
PropTypes.shape({
    color: PropsType.string,
    fontSize: PropsType.number,
})

// 加上isRequired，父组件未提供，将会报错
PropsTypes.func.isRequired
PropsTypes.number.isRequired

// 自定义检查器
customProp: function (props, propsName, componentName){
    if(!/matchme/.test(props[propName])) {
        return new Error(
            'Invalid prop' + propName + 'supplied to '+ componentName +' Validation failed'
        )
    }
}

// 提供一个自定义检查器
customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
    if (!/matchme/.test(propValue[key])) {
      return new Error(
        'Invalid prop `' + propFullName + '` supplied to' +
        ' `' + componentName + '`. Validation failed.'
      );
    }
})
</code></pre></div><p>TODO 设定默认值</p> <div class="language- extra-class"><pre class="language-text"><code>defaultProps = {
    name: 'Stranger',
}
</code></pre></div><h2 id="state"><a href="#state" aria-hidden="true" class="header-anchor">#</a> state</h2> <ul><li>state代表组件的内部状态，用于记录自身数据变化</li> <li>通常在组件类的构造函数结尾处初始化state</li> <li>通过对<code>this.state</code>的赋值完成对组件state的初始化</li> <li>组件的state必须是一个javascript对象，不能是string或者number这样的简单数据类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>constructor(props){
    supre(props);
    this.state = {
        ...
    }
}
</code></pre></div><h2 id="state的读取和设置"><a href="#state的读取和设置" aria-hidden="true" class="header-anchor">#</a> state的读取和设置</h2> <ul><li>通过<code>this.state</code>可以读取到组件当前的state值</li> <li>修改必须通过<code>this.setState</code>函数</li></ul> <p>TODO</p> <ul><li>直接修改state的值，虽然事实上改变了组件内部状态，但只是野蛮地修改了state，却没有驱动组件进行重新渲染</li> <li><code>this.setState</code>函数所做的事情，首先是改变this.state的值，然后驱动组件经历更新过程，这样才有机会让this.state里新的值出现在界面上</li></ul> <h2 id="prop和state的对比"><a href="#prop和state的对比" aria-hidden="true" class="header-anchor">#</a> prop和state的对比</h2> <ul><li>prop用于定义外部接口，state用于记录内部状态</li> <li>prop的赋值在父组件使用组件时，state的赋值在组件内部</li> <li>组件不应该改变prop的值，而state存在的目的就是让组件来改变的</li></ul> <p>TODO</p> <ul><li>严格来说，React并没有办法阻止你去修改传入的prop对象。所以，每个开发者就把这当作一个规矩，在编码中一定不要踩这儿的红线，不然最后可能遇到不可预料的bug</li></ul> <h2 id="组件生命周期"><a href="#组件生命周期" aria-hidden="true" class="header-anchor">#</a> 组件生命周期</h2> <ul><li>挂载过程（Mount）组件第一次在DOM树中渲染过程</li> <li>更新过程（Update）组件被重新渲染的过程</li> <li>卸载过程（Unmount）组件从DOM中删除的过程</li></ul> <p>TODO</p> <ul><li>三种不同的过程，React库会依次调用组件的一些成员函数，这些函数被称为生命周期。所以，要定制一个React组件，实际上就是定制这些生命周期</li></ul> <h2 id="装载过程"><a href="#装载过程" aria-hidden="true" class="header-anchor">#</a> 装载过程</h2> <p>constructor 组件类的实例</p> <ul><li>初始化state</li> <li>绑定成员函数的this环境</li></ul> <p>TODO</p> <ul><li>在ES6语法中，类的每个成员函数在执行时的this并不是和类实例自动绑定的。而在构造函数中，this就是当前组件实例，所以为了方便将来调用，往往在构造函数中将这个实例的特定函数绑定this为当前实例</li> <li>无状态的React组件不需要定义构造函数</li></ul> <hr> <p>getInitalState 初始化state</p> <ul><li>函数的返回值用来初始化组件的this.state</li></ul> <p>TODO</p> <ul><li>这个函数只在React.createClass方法创造的组件类才会用到</li> <li>只出现在装载过程，在组件整个生命周期过程中，这个函数只被调用一次</li></ul> <hr> <p>getDefaultProps 初始化props</p> <ul><li>函数的返回值可以作为props的初始值</li></ul> <p>TODO</p> <ul><li>这个函数只在React.createClass方法创造的组件类才会用到</li> <li>只出现在装载过程，在组件整个生命周期过程中，这个函数只被调用一次</li></ul> <hr> <p>render 生成JSX描述结构</p> <ul><li>返回一个JSX描述的结构，由React来操作渲染过程</li> <li>组件在某些情况下选择没有东西可渲染，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需渲染任何DOM元素</li> <li>完全根据<code>this.state</code>和<code>this.prop</code>来决定返回结果，而且不会产生任何副作用</li></ul> <p>TODO</p> <ul><li>render是一个必要函数，因为React.Component类对除了render之外的生命周期函数都有默认实现</li> <li>在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态改变</li></ul> <hr> <p>componentWillMount 生成结构前</p> <ul><li>会在调用render函数之前调用</li> <li>发生在“将要装载”的时候，这个时候没有任何渲染结果，即使调用<code>this.setState</code>修改状态也不会引发重新渲染，所有可以在componentWillMount中做的事情，都可以提前到constructor中去做，这个函数存在的主要目的是为了和componentDidMount对称</li></ul> <p>TODO</p> <ul><li>可以在服务器端调用，也可以在浏览器端调用</li></ul> <hr> <p>componentDidMount 生成结构后</p> <ul><li>会在调用render函数之后调用</li> <li>可以让React和其他库配合使用，因为componentDidMount之后DOM结构已经完全渲染，这个时候可以调用任意插件或者库来操作DOM</li> <li>可以区分服务器端和浏览器端操作</li></ul> <p>TODO</p> <ul><li>render函数被调用之后，componentDidMount函数并不是会立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被“装载”到了DOM树上。componentDidMount可不是紧跟着render函数被调用，当所有组件的render函数都被调用之后，组件的componentDidMount才会连在一起被调用。因为render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示对象，然后由React库来根据对象决定如何渲染。而React库肯定是要把所有组件返回的结果综合起来，才知道该如何产生对应的DOM修改。所以，只有React库调用组件的render函数之后，才有可能最终完成装载，这个时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。</li> <li>只能在浏览器端被调用，在服务器端不会被调用，因为“装载”是一个创建完成组件并放到DOM树上的过程，那么，真正的“装载”是不可能在服务端完成的，因为服务端渲染并不会产生DOM树，通过React组件产生的只是一个纯脆的字符串而已。</li></ul> <h2 id="更新过程"><a href="#更新过程" aria-hidden="true" class="header-anchor">#</a> 更新过程</h2> <p>componentWillReceiveProps(nextProps)</p> <ul><li>父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数</li> <li>通过<code>this.setState</code>方法触发的更新过程不会调用这个函数，因为这个函数适合根据新的prop值（也就是nextProps）来计算出是不是需要更新内部状态state</li> <li>nextProps代表的是这一次渲染传入的prop值，<code>this.prop</code>代表的上一次渲染时的prop值，只有两者有变化的时候才调用<code>this.setState</code>更新内容状态</li></ul> <p>TODO</p> <ul><li>每个组件都可以通过<code>this.forecUpdate()</code>函数来强制引发一次重绘、</li> <li>在React组件中，完全可以只渲染一个子组件，而其他组件完全不需要渲染，这是提高React性能的重要方式</li></ul> <hr> <p>shouldComponentUpdate(nextProp,nextState) 决定一个组件什么时候需要渲染</p> <ul><li>render和shouldComponentUpdate，也是React生命周期中唯二两个要求有返回结果的函数</li> <li>shouldComponentUpdate函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要触发渲染</li> <li>更新过程中，React库首先调用shouldComponentUpdate函数，如果这个函数返回true，那么就会继续更新过程，接下来触发调用render函数；反之，如果得到一个false，那么就立刻停止更新过程，也就不会引发后续的渲染了</li> <li>如果我们要定义shouldComponentUpdate，那么就要根据nextProp和nextState，外加<code>this.prop</code>和<code>this.state</code>来判断出是返回true还是返回false</li> <li>默认方式是返回true，如果我们要追求更高性能，就不能满足于默认实现，需要定制这个函数shouldComponentUpdate</li></ul> <p>TODO</p> <ul><li>通过<code>this.setState</code>函数引起的更新过程，并不是立刻更新组件的state值，在执行到函数shouldComponentUpdate的时候，this.state依然是this.setState函数执行之前的值，所以我们要做的实际上就是在nextProp和nextState、<code>this.prop</code>和<code>this.state</code>中互相对比</li></ul> <hr> <p>componentWillUpdate和componentDidUpdate，render更新前，render更新后</p> <ul><li>如果组件的shouldComponentUpdate函数返回true，React接下来就会依次调用对应组件的componentWillUpdate和componentDidUpdate函数</li> <li>componentDidUpdate函数，并不是只在浏览器端才执行的，无论更新过程发生在服务端还是浏览器端，该函数都会被调用</li></ul> <p>TOOD</p> <ul><li>实际上，使用React做服务端渲染时，基本不会经历更新过程，因为在服务器端只需要产出HTML字符串，一个装载过程就足够产出HTML了，所以正常情况下服务器端不会调用componentDidUpdate函数，如果调用了，说明我们的程序有错误，需要改进</li></ul> <h2 id="卸载过程"><a href="#卸载过程" aria-hidden="true" class="header-anchor">#</a> 卸载过程</h2> <p>componentWillUnmount</p> <ul><li>React组件的卸载过程只涉及一个函数componentWillUnmount，当React组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用，所以这个函数适合做一些请理性的工作</li></ul> <p>TODO</p> <ul><li>componentWillUnmount中的工作往往和componentDidMount有关，比如，在componentDidMount中用非React的方法创造了一些DOM元素，如果撒手不管可能会造成内存泄漏，那就需要在componentWillUnmount中把这些创造的DOM元素清理掉</li></ul> <h2 id="向组件外传递数据，如何让父组件知道子组件的状态"><a href="#向组件外传递数据，如何让父组件知道子组件的状态" aria-hidden="true" class="header-anchor">#</a> 向组件外传递数据，如何让父组件知道子组件的状态</h2> <ul><li>利用prop</li> <li>组件的prop可以是任何javascript对象，而在javascript中，函数是一等公民，函数本身就可以被看做一种对象，既可以像其他对象一样作为prop的值从父组件传递给子组件，又可以被子组件作为函数调用</li></ul> <h2 id="state和prop的局限"><a href="#state和prop的局限" aria-hidden="true" class="header-anchor">#</a> state和prop的局限</h2> <ul><li>当数据出现重复，会带来一个问题就是如何保证重复的数据一致，如果数据存在多份而且不一致的情况，那就很难决定到底使用哪个数据作为正确结果</li> <li>把数据源放在React组件之外形成全局状态，让各个组件保持全局状态的一致，这样就更容易控制</li> <li>全局状态就是唯一的可靠的数据源</li> <li>在一个应用中，包含三级或者三级以上的组件结构，顶层的祖父级组件想要传递一个数据给最低层的子组件，用prop方式，就只能通过父组件中转，也许中间那一层父组件根本用不上这个prop，但是依然要支持这个prop，扮演好搬运工的角色，只因为子组件用得上，这明显违反了低耦合的设计要求</li></ul> <p>TODO</p> <ul><li>只用React的state来存储状态的一个缺点，那就是数据的冗余和重复</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/doc/assets/js/app.37ba04a1.js" defer></script><script src="/doc/assets/js/2.387e38e1.js" defer></script><script src="/doc/assets/js/11.a1378e1b.js" defer></script>
  </body>
</html>
