# 从 Flux 到 Redux

[TOC]

## 相关
* [Flux 筆記](http://andyyou.logdown.com/posts/241839-flux-notes)

## Flux
* 单项数据流
* React是用来替换jQuery的，Flux就是以替换BackBone.js、Ember.js等MVC一族框架为目的
* 更严格的数据流控制
* Dispatcher，处理动作分发，维持Store之间的依赖关系
* Store，负责存储数据和处理数据逻辑相关逻辑
* Action，驱动Dispatcher的javascript对象
* View，视图部分，负责显示用户界面

## MVC框架
* Model（模型）负责管理数据，大部分业务逻辑也应该放在Model中
* View（视图）负责渲染用户界面，应该避免在View中涉及业务逻辑
* Controller（控制器）负责接受用户输入，根据用户输入调用对应的Model部分逻辑，把产生的数据结果交给View部分，让View渲染出必要的输出
* 把一个应用划分为多个组件，分而治之

## MVC框架的缺陷
* 不同模块之间的依赖关系让系统变的“脆弱而且不可预测”
* 让Model和View直接通信，会导致不可预见的问题
* 对于浏览器端MVC框架，存在用户的交互处理，界面渲染出来之后，Model和View依然存在于浏览器中，这时候就会诱导开发者为了简便，让现存的Model和View直接对话

TODO

* 对于MVC框架，为了让数据流可控，Controller应该是中心，当View要传递消息给Model时，应该调用Controller的方法，同样，当Model要更新View时，也应该通过Controller引发新的渲染
* 当需要增加新的功能时，要做的是增加一层新的Action类型，Dispatcher的对外接口并不用改变
* 当需要扩充应用所能处理的“请求”时，MVC方法就需要增加新的Controller，而Flux则只是增加新的Action

## Flux应用
* 引入flux库中的Dispatcher类，然后创造一个新对象作为这个文件的默认输出，在其他代码中，将会引用这个全局唯一的Dispatcher对象
* action顾名思义代表一个动作，不过这个动作只是一个普通的javascript对象。代表一个动作的纯数据，类似于DOM API中的事件（event），只不过它是更加纯粹的数据对象
* action对象不自带方法，就是纯粹的数据
* Store也是一个对象，这个对象存储应用状态，同时还要接受Dispatcher派发的动作，根据动作来决定是否要更新应用状态
* 当Store的状态发生变化的时候，需要通知应用的其他部分做必要的响应
* 让Store继承EventEmitter.prototype，等于让Store成为了EventEmitter对象，一个EventEmitter对象拥有emit函数，on函数，removeListener函数
* emit函数，可以广播一个特定事件，第一个参数是字符串类型的事件名称
* on函数，可以增加一个挂在这个EventEmitter对象特定事件上的处理函数，第一个参数是字符串类型的事件名称，第二个参数是处理函数
* removeListener函数和on函数做的事情相反，删除挂在这个EventEmitter对象特定事件上的处理函数，和on函数一样，第一个参数是事件名称，第二个参数是处理函数。

TODO

* 如果要调用removeListener函数，就一定要保留对处理函数的引用
* waitFor函数，接受一个数组作为参数，数组中每个元素都是一个Dispatcher-herregister函数的返回结果，也就是所谓的dispatcherToken。这个waitFor函数告诉Dispatcher，当前的处理必须暂停，直到dispatchToken代表那些已经注册回调函数执行结束才能继续。javascript中不可能存在线程之间的等待这回事，这个waitFor函数当然并不是用多线程实现的，只是在调用waitFor的时候，把控制权交给Dispatcher，让Dispatcher检查一下dispatcherToken代表的回调函数有没有执行，如果已经执行，那就直接继续，如果还没有执行，那就调用dispatchToken代表的回调函数之后waitFor才返回

## Flux框架中React组件需要实现功能

* 创建时要读区Store上状态来初始化组件内部状态
* 当Store上状态发生变化时，组件要立刻同步更新内部状态保持一致
* View如果要改变Store状态，必须而且只能排发action

![](http://o7s01mlar.bkt.clouddn.com/2018-08-29-15355572649375.jpg)

Dispatcher层

```
// AppDispatcher.js
import {Dispatcher} from 'flux';

export default new Dispatcher();
```

Action层

```
// Action.js
import AppDispatcher from './AppDispatcher.js';

/**
 * 注册回调函数，返回一个 token 供在 waitFor() 使用
 * @param   {function callback} 
 * @returns {string}
 */ 
AppDispatcher.register(callback)

/**
 * 通过 token 移除回调
 * @parms   {string} id 
 * @returns {void}
 */ 
AppDispatcher.unregister(string id)

/**
 * 在指定的回调函数执行之后才执行当前回调。这个方法只能在分发动作的回调函数中使用
 * @param   {array} ids
 * @returns {void}
 */ 
AppDispatcher.waitFor(ids)

/** 
 * 分发动作、数据，给所有注册回调
 * @param   {Object}
 * @returns {void}
 */
AppDispatcher.dispatch({
    type: '',// 类型
    payload: '',// 数据
}); 

/**
 * 返回 Dispatcher 当前是否处在分发的状态
 * @returns {boolean}
 */
AppDispatcher.isDispatching()

```

Store层，继承events的EventEmitter

```
// Store.js
import AppDispatcher from 'AppDispatcher.js';
import {EventEmitter} from 'events';

const CHANGE_EVENT = 'change';// 定义change事件名
const data;// 定义数据

class Store extends EventEmitter{
    // Getter 方法暴露给外部获取 Store 数据
    constructor(){
        super();
        
        // 注册到 dispatcher，通过动作类型过滤处理当前 Store 关心的动作
        this.dispatcherToken = AppDispatcher.register((action)=>{
            if(action.type == ActionType){
                this.emitChange();
            }
            ...
            // 或者
            // 确保dispatcherToken执行完成
            AppDispatcher.waitFor([dispatcherToken]);
            this.emitChange();            
        })
    }
    
    getAll(){
       return  data
    }
    
    // 触发 change 事件
    emitChange(){
        this.emit(CHANGE_EVENT)
    }
    
    // 提供给外部 View 绑定 change 事件
    addChangeListener: function(callback) {
        this.on(CHANGE_EVENT, callback);
    }
    
    // 删除提供给外部 View 绑定的 change 事件
    removeChangeListener(callback){
        this.removeChangeListener(CHANGE_EVENT, callback);
    };
}

```

View层

```
// View.js
import Store from 'Store';
import React from 'react';
import Action from 'Action';
import AppDispatcher from 'AppDispatcher';

class View extends React.Component{
    constructor(){
        supre();
        
        this.onChange = this.onChange.bind(this);
        this.handelChange = this.handleChange.bind(this);
        
        this.state = {
            data: Store.getAll(),
        }
    }
    
    componentDidMount(){
        Store.addChangeListener(this.onChange)
    }
    
    componentWillUnmount(){
        Store.removeChangeListener(this.onChange)
    }

    onChange(){
        const newData = Store.getAll();
        this.setState({
          data: newData,
        });
    }
    
    handelChange(){
        AppDispatcher.dispatch({
            type: '',// 类型
            payload: '',// 数据
        }); 
    }
    
    render(){
        return(
            <button onClick={this.handelChange}></button>
        )
    }
}


```




